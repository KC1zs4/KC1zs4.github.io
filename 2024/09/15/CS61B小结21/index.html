<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=5"
    />
    <meta name="description" content="后面考试时再过一遍印象就深了  Index Index Resources Q&amp;A Principle of DataStruct 0. Extension 0. 1. Javadoc 0. 2 垃圾回收条件 0. 3 HOF after&#x2F;include java 8 0. 4 CallBack Function in Java(搜Subtype Polymorphism vs">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61B小结21">
<meta property="og:url" content="https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/index.html">
<meta property="og:site_name" content="KC1zs4&#39;s Blog">
<meta property="og:description" content="后面考试时再过一遍印象就深了  Index Index Resources Q&amp;A Principle of DataStruct 0. Extension 0. 1. Javadoc 0. 2 垃圾回收条件 0. 3 HOF after&#x2F;include java 8 0. 4 CallBack Function in Java(搜Subtype Polymorphism vs">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Resizing.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/comparable.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/collection_hierarchy.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/checked_exceptions.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/access_modifiers.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/collection_hierarchy.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Comlicated_Counting.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/asymptotics2_tree2.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/static_binary_search.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/bs_total.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/ms_total.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Big_Three.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Amortization.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_Compare.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/WeightedQU.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/WeightQU_example.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Prove_WQU.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_compareE.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/RunTime_B_Tree.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Why_BRT.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_LoadFactor.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_Condition.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_Java.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Heap_Operation.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/TR_4.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/TR_ArraySentinel.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapArray1.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapArray2.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapIndex.jpg">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/DataStructSummary.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/DataStructSum2.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_Huffman.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_2Models.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_Model2example.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Traversal_ways.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_Runtime.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dfs.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_bfs.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_adjMatrix.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dijkstraProof.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dijkstraRuntime.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/MST_KruskalRuntime.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Tire_Array.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Trie_AutoComplete.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Topo_name.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_shellsort.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_differentShellsort.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_basicRuntime.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_quickaverage.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_quickRuntime.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_stable.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_LSDbase.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_Summary.png">
<meta property="og:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_and_Sorting.png">
<meta property="article:published_time" content="2024-09-14T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-26T11:47:15.458Z">
<meta property="article:tag" content="cs大件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kc1zs4.github.io/pic/CS61B%E5%B0%8F%E7%BB%9321/Resizing.jpg">    
    <link
        rel="shortcut icon"
        href="/images/favicon.ico"
    />
       
    <link
        rel="icon"
        type="image/png"
        href="/images/favicon-192x192.png"
        sizes="192x192"
    />
       
    <link
        rel="apple-touch-icon"
        sizes="180x180"
        href="/images/apple-touch-icon.png"
    />
      
    <!-- title -->
    <title>CS61B小结21</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6JGRC9FT2"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-Z6JGRC9FT2');
  </script>

 <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
     
    <!-- mathjax -->
    
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/10/25/ctf3r%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0vps/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/12/05/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&text=CS61B小结21"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&is_video=false&description=CS61B小结21"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CS61B小结21&body=Check out this article: https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&name=CS61B小结21&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&t=CS61B小结21"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Index"><span class="toc-number">1.</span> <span class="toc-text">Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resources"><span class="toc-number">2.</span> <span class="toc-text">Resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-A"><span class="toc-number">3.</span> <span class="toc-text">Q&amp;A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Principle-of-DataStruct"><span class="toc-number">4.</span> <span class="toc-text">Principle of DataStruct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-Extension"><span class="toc-number">5.</span> <span class="toc-text">0. Extension</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-Javadoc"><span class="toc-number">5.1.</span> <span class="toc-text">0. 1. Javadoc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">0. 2 垃圾回收条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-3-HOF-after-include-java-8"><span class="toc-number">5.3.</span> <span class="toc-text">0. 3 HOF after&#x2F;include java 8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-4-CallBack-Function-in-Java-%E6%90%9CSubtype-Polymorphism-vs-HoFs"><span class="toc-number">5.4.</span> <span class="toc-text">0. 4 CallBack Function in Java(搜Subtype Polymorphism vs. HoFs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-5-Nested-Class%E4%B8%8EInterface%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%BA%A7%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">0. 5 Nested Class与Interface的访问控制级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-6-How-to-deal-with-Exceptions"><span class="toc-number">5.6.</span> <span class="toc-text">0. 6 How to deal with Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-7-Set-of-E%E2%80%A6-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.7.</span> <span class="toc-text">0. 7 Set.of(E…)方法用于可以直接进行初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Basic-Classes-and-Testing"><span class="toc-number">6.</span> <span class="toc-text">1. Basic Classes and Testing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Defining-and-Using-Classes"><span class="toc-number">6.1.</span> <span class="toc-text">1. 1 Defining and Using Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Testing"><span class="toc-number">6.2.</span> <span class="toc-text">1. 2 Testing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lists-Introduction"><span class="toc-number">7.</span> <span class="toc-text">2. Lists(Introduction)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-References-Recursion-and-Lists"><span class="toc-number">7.1.</span> <span class="toc-text">2. 1 References,Recursion,and Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SLLists-Nested-Classes-Sentinel-Nodes"><span class="toc-number">7.2.</span> <span class="toc-text">2. 2 SLLists, Nested Classes, Sentinel Nodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-DLLists-Arrays"><span class="toc-number">7.3.</span> <span class="toc-text">2. 3 DLLists, Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-ALists-Resizing"><span class="toc-number">7.4.</span> <span class="toc-text">2. 4 ALists, Resizing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Futher-Java-Feature"><span class="toc-number">8.</span> <span class="toc-text">3. Futher Java Feature</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Inheritance-Implements"><span class="toc-number">8.1.</span> <span class="toc-text">3. 1 Inheritance, Implements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Extends-Casting-Higher-Order-Functions"><span class="toc-number">8.2.</span> <span class="toc-text">3. 2 Extends, Casting, Higher Order Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Subtype-Polymorphism-vs-HoFs"><span class="toc-number">8.3.</span> <span class="toc-text">3. 3 Subtype Polymorphism vs. HoFs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Java-Packages-and-Library-gitbook"><span class="toc-number">8.4.</span> <span class="toc-text">3. 4 Java Packages and Library(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Exceptions-Iterators-Object-Methods"><span class="toc-number">8.5.</span> <span class="toc-text">3. 5 Exceptions, Iterators, Object Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-JAR-FILE-gitbook"><span class="toc-number">8.6.</span> <span class="toc-text">3. 6 JAR FILE(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Access-Control-gitbook"><span class="toc-number">8.7.</span> <span class="toc-text">3. 7 Access Control(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-Generic-and-AutoBoxing-gitbook"><span class="toc-number">8.8.</span> <span class="toc-text">3. 8 Generic and AutoBoxing(gitbook)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Abstraction-ADTs-and-Asymtotics-Annlysis"><span class="toc-number">9.</span> <span class="toc-text">4. Abstraction, ADTs and Asymtotics Annlysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-OurMap-gitbook"><span class="toc-number">9.1.</span> <span class="toc-text">4. 1 OurMap(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Encapsulation-API%E2%80%99s-ADT%E2%80%99s"><span class="toc-number">9.2.</span> <span class="toc-text">4. 2 Encapsulation, API’s, ADT’s</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Asymptotics-I-II"><span class="toc-number">9.3.</span> <span class="toc-text">4. 3 Asymptotics I II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Omega-and-Amortized-Analysis-gitbook"><span class="toc-number">9.4.</span> <span class="toc-text">4. 4 Omega and Amortized Analysis(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Disjoint-Sets-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86"><span class="toc-number">9.5.</span> <span class="toc-text">4. 5 Disjoint Sets(不相交集)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Trees-and-Hashing"><span class="toc-number">10.</span> <span class="toc-text">5. Trees and Hashing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Binary-Search-Tree-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">10.1.</span> <span class="toc-text">5. 1 Binary Search Tree(二叉搜索树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-B-Tree-Maybe-Boeing-Tree"><span class="toc-number">10.2.</span> <span class="toc-text">5. 2 B-Tree (Maybe Boeing Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Black-Red-Tree-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text">5. 3 Black-Red-Tree (红黑树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Hashing"><span class="toc-number">10.4.</span> <span class="toc-text">5. 4 Hashing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Heaps-and-PQs"><span class="toc-number">10.5.</span> <span class="toc-text">5. 5 Heaps and PQs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Data-Structure-Summary"><span class="toc-number">10.6.</span> <span class="toc-text">5. 6 Data Structure Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Compression-Originally-38"><span class="toc-number">10.7.</span> <span class="toc-text">5. 7 Compression(Originally 38)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-Compression-Complexity-and-P-NP"><span class="toc-number">10.8.</span> <span class="toc-text">5. 8 Compression, Complexity, and P&#x3D;NP?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Graphs"><span class="toc-number">11.</span> <span class="toc-text">6. Graphs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Tree-and-Graph-Traversals"><span class="toc-number">11.1.</span> <span class="toc-text">6. 1 Tree and Graph Traversals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Graph-Traversals-and-Implementations-BFS-and-DFS"><span class="toc-number">11.2.</span> <span class="toc-text">6. 2 Graph Traversals and Implementations(BFS and DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Shortest-Paths"><span class="toc-number">11.3.</span> <span class="toc-text">6. 3 Shortest Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Minimum-Spanning-Trees"><span class="toc-number">11.4.</span> <span class="toc-text">6. 4 Minimum Spanning Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Range-Searching-and-Multi-Dimensional-Data"><span class="toc-number">11.5.</span> <span class="toc-text">6. 5 Range Searching and Multi-Dimensional Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-Prefix-Operations-and-Tries"><span class="toc-number">11.6.</span> <span class="toc-text">6. 6 Prefix Operations and Tries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-DAGs-Reduction-Decomposition"><span class="toc-number">11.7.</span> <span class="toc-text">6. 7 DAGs, Reduction, Decomposition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Sorting"><span class="toc-number">12.</span> <span class="toc-text">7. Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Basic-Sorts"><span class="toc-number">12.1.</span> <span class="toc-text">7. 1 Basic Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Quick-Sorts"><span class="toc-number">12.2.</span> <span class="toc-text">7. 2 Quick Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-More-Quick-Sort-Comparision-Based-Sorting-Summary"><span class="toc-number">12.3.</span> <span class="toc-text">7. 3  More Quick Sort, (Comparision Based) Sorting Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-Sorting-and-Algorithmic-Bounds"><span class="toc-number">12.4.</span> <span class="toc-text">7. 4 Sorting and Algorithmic Bounds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-Radix-Sorts"><span class="toc-number">12.5.</span> <span class="toc-text">7. 5 Radix Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-Sorting-and-Data-Structures-Conclusion"><span class="toc-number">12.6.</span> <span class="toc-text">7. 6 Sorting and Data Structures Conclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-Sorting-Implementation-Extra-in-%E2%80%9CSorting-and-Algorithmic-Bounds%E2%80%9D-ppt"><span class="toc-number">12.7.</span> <span class="toc-text">7. 7 Sorting Implementation (Extra in “Sorting and Algorithmic Bounds” ppt)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Extra-Topic-SoftWare-Engineering"><span class="toc-number">13.</span> <span class="toc-text">8. Extra Topic: SoftWare Engineering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-SE-I-Complexity"><span class="toc-number">13.1.</span> <span class="toc-text">8. 1 SE I: Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-SE-II-Modular"><span class="toc-number">13.2.</span> <span class="toc-text">8. 2 SE II: Modular</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        CS61B小结21
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name"></span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-09-14T16:00:00.000Z" class="dt-published" itemprop="datePublished">2024-09-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/CS/">CS</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/cs%E5%A4%A7%E4%BB%B6/" rel="tag">cs大件</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <blockquote>
<p>后面考试时再过一遍印象就深了</p>
</blockquote>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul>
<li><a href="#index">Index</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#qa">Q&amp;A</a></li>
<li><a href="#principle-of-datastruct">Principle of DataStruct</a></li>
<li><a href="#0-extension">0. Extension</a><ul>
<li><a href="#0-1-javadoc">0. 1. Javadoc</a></li>
<li><a href="#0-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6">0. 2 垃圾回收条件</a></li>
<li><a href="#0-3-hof-afterinclude-java-8">0. 3 HOF after&#x2F;include java 8</a></li>
<li><a href="#0-4-callback-function-in-java%E6%90%9Csubtype-polymorphism-vs-hofs">0. 4 CallBack Function in Java(搜Subtype Polymorphism vs. HoFs)</a></li>
<li><a href="#0-5-nested-class%E4%B8%8Einterface%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%BA%A7%E5%88%AB">0. 5 Nested Class与Interface的访问控制级别</a></li>
<li><a href="#0-6-how-to-deal-with-exceptions">0. 6 How to deal with Exceptions</a></li>
<li><a href="#0-7-setofe%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">0. 7 Set.of(E…)方法用于可以<strong>直接</strong>进行初始化</a></li>
</ul>
</li>
<li><a href="#1-basic-classes-and-testing">1. Basic Classes and Testing</a><ul>
<li><a href="#1-1-defining-and-using-classes">1. 1 Defining and Using Classes</a></li>
<li><a href="#1-2-testing">1. 2 Testing</a></li>
</ul>
</li>
<li><a href="#2-listsintroduction">2. Lists(Introduction)</a><ul>
<li><a href="#2-1-referencesrecursionand-lists">2. 1 References,Recursion,and Lists</a></li>
<li><a href="#2-2-sllists-nested-classes-sentinel-nodes">2. 2 SLLists, Nested Classes, Sentinel Nodes</a></li>
<li><a href="#2-3-dllists-arrays">2. 3 DLLists, Arrays</a></li>
<li><a href="#2-4-alists-resizing">2. 4 ALists, Resizing</a></li>
</ul>
</li>
<li><a href="#3-futher-java-feature">3. Futher Java Feature</a><ul>
<li><a href="#3-1-inheritance-implements">3. 1 Inheritance, Implements</a></li>
<li><a href="#3-2-extends-casting-higher-order-functions">3. 2 Extends, Casting, Higher Order Functions</a></li>
<li><a href="#3-3-subtype-polymorphism-vs-hofs">3. 3 Subtype Polymorphism vs. HoFs</a></li>
<li><a href="#3-4-java-packages-and-librarygitbook">3. 4 Java Packages and Library(gitbook)</a></li>
<li><a href="#3-5-exceptions-iterators-object-methods">3. 5 Exceptions, Iterators, Object Methods</a></li>
<li><a href="#3-6-jar-filegitbook">3. 6 JAR FILE(gitbook)</a></li>
<li><a href="#3-7-access-controlgitbook">3. 7 Access Control(gitbook)</a></li>
<li><a href="#3-8-generic-and-autoboxinggitbook">3. 8 Generic and AutoBoxing(gitbook)</a></li>
</ul>
</li>
<li><a href="#4-abstraction-adts-and-asymtotics-annlysis">4. Abstraction, ADTs and Asymtotics Annlysis</a><ul>
<li><a href="#4-1-ourmapgitbook">4. 1 OurMap(gitbook)</a></li>
<li><a href="#4-2-encapsulation-apis-adts">4. 2 Encapsulation, API’s, ADT’s</a></li>
<li><a href="#4-3-asymptotics-i-ii">4. 3 Asymptotics I II</a></li>
<li><a href="#4-4-omega-and-amortized-analysisgitbook">4. 4 Omega and Amortized Analysis(gitbook)</a></li>
<li><a href="#4-5-disjoint-sets%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86">4. 5 Disjoint Sets(不相交集)</a></li>
</ul>
</li>
<li><a href="#5-trees-and-hashing">5. Trees and Hashing</a><ul>
<li><a href="#5-1-binary-search-tree%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">5. 1 Binary Search Tree(二叉搜索树)</a></li>
<li><a href="#5-2-b-tree-maybe-boeing-tree">5. 2 B-Tree (Maybe Boeing Tree)</a></li>
<li><a href="#5-3-black-red-tree-%E7%BA%A2%E9%BB%91%E6%A0%91">5. 3 Black-Red-Tree (红黑树)</a></li>
<li><a href="#5-4-hashing">5. 4 Hashing</a></li>
<li><a href="#5-5-heaps-and-pqs">5. 5 Heaps and PQs</a></li>
<li><a href="#5-6-data-structure-summary">5. 6 Data Structure Summary</a></li>
<li><a href="#5-7-compressionoriginally-38">5. 7 Compression(Originally 38)</a></li>
<li><a href="#5-8-compression-complexity-and-pnp">5. 8 Compression, Complexity, and P&#x3D;NP?</a></li>
</ul>
</li>
<li><a href="#6-graphs">6. Graphs</a><ul>
<li><a href="#6-1-tree-and-graph-traversals">6. 1 Tree and Graph Traversals</a></li>
<li><a href="#6-2-graph-traversals-and-implementationsbfs-and-dfs">6. 2 Graph Traversals and Implementations(BFS and DFS)</a></li>
<li><a href="#6-3-shortest-paths">6. 3 Shortest Paths</a></li>
<li><a href="#6-4-minimum-spanning-trees">6. 4 Minimum Spanning Trees</a></li>
<li><a href="#6-5-range-searching-and-multi-dimensional-data">6. 5 Range Searching and Multi-Dimensional Data</a></li>
<li><a href="#6-6-prefix-operations-and-tries">6. 6 Prefix Operations and Tries</a></li>
<li><a href="#6-7-dags-reduction-decomposition">6. 7 DAGs, Reduction, Decomposition</a></li>
</ul>
</li>
<li><a href="#7-sorting">7. Sorting</a><ul>
<li><a href="#7-1-basic-sorts">7. 1 Basic Sorts</a></li>
<li><a href="#7-2-quick-sorts">7. 2 Quick Sorts</a></li>
<li><a href="#7-3--more-quick-sort-comparision-based-sorting-summary">7. 3  More Quick Sort, (Comparision Based) Sorting Summary</a></li>
<li><a href="#7-4-sorting-and-algorithmic-bounds">7. 4 Sorting and Algorithmic Bounds</a></li>
<li><a href="#7-5-radix-sorts">7. 5 Radix Sorts</a></li>
<li><a href="#7-6-sorting-and-data-structures-conclusion">7. 6 Sorting and Data Structures Conclusion</a></li>
<li><a href="#7-7-sorting-implementation-extra-in-sorting-and-algorithmic-bounds-ppt">7. 7 Sorting Implementation (Extra in “Sorting and Algorithmic Bounds” ppt)</a></li>
</ul>
</li>
<li><a href="#8-extra-topic-software-engineering">8. Extra Topic: SoftWare Engineering</a><ul>
<li><a href="#8-1-se-i-complexity">8. 1 SE I: Complexity</a></li>
<li><a href="#8-2-se-ii-modular">8. 2 SE II: Modular</a></li>
</ul>
</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ol>
<li><a target="_blank" rel="noopener" href="https://joshhug.gitbooks.io/hug61b/content/">cs61b gitbook</a></li>
</ol>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li>is there any simpler way to prove amortization in 4.4?</li>
<li>didn’t cover AVL tree, jush says the llrb is the best or good(simple and clear) enough(mit 6.006 has AVL tree)</li>
<li>红黑树笔记还没记下来，k-d tree也还没有</li>
<li>未实现:AVL tree, Bellman-Ford(对于负权重)</li>
<li>Bst实现Trie如何实现，想不出来a, b, c, d怎么可以有序</li>
<li>后续匹配，6.6最后的other部分</li>
<li>为什么不是DAGs没办法找出topological sort</li>
<li>Shortest paht in DAGs中没有将bellman-ford</li>
<li>quick sort为什么hate要&#x3D;&#x3D;</li>
</ol>
<h2 id="Principle-of-DataStruct"><a href="#Principle-of-DataStruct" class="headerlink" title="Principle of DataStruct"></a>Principle of DataStruct</h2><ol>
<li>并不是要某一个操作一定要少，这是一门设计N-&gt;1的结构课程(目的是防止N-&gt;infinity时数据的结构)<ol>
<li>在B-Tree处体现得最好</li>
</ol>
</li>
<li>思维<ol>
<li>dijkstra:无法一下子从全局切入就回到这一步进行切入</li>
<li>tries:减少重复</li>
</ol>
</li>
</ol>
<h2 id="0-Extension"><a href="#0-Extension" class="headerlink" title="0. Extension"></a>0. Extension</h2><h3 id="0-1-Javadoc"><a href="#0-1-Javadoc" class="headerlink" title="0. 1. Javadoc"></a>0. 1. Javadoc</h3><ol>
<li>以<code>/** ... */</code>为格式，为类、接口、方法、构造函数以及变量编写文档，作为api文档</li>
<li>常用注释标记<ol>
<li>@param</li>
<li>@return</li>
<li>@throws 可能抛出的异常</li>
<li>@deprecated 是否仍然推荐</li>
<li>@author</li>
</ol>
</li>
</ol>
<h3 id="0-2-垃圾回收条件"><a href="#0-2-垃圾回收条件" class="headerlink" title="0. 2 垃圾回收条件"></a>0. 2 垃圾回收条件</h3><ol>
<li>引用断裂</li>
<li>不可达</li>
</ol>
<h3 id="0-3-HOF-after-include-java-8"><a href="#0-3-HOF-after-include-java-8" class="headerlink" title="0. 3 HOF after&#x2F;include java 8"></a>0. 3 HOF after&#x2F;include java 8</h3><ol>
<li>Java 8开始引入了Lambda表达式和函数式接口，也可以创建自己的函数式工具</li>
<li>去问chatgpt</li>
</ol>
<h3 id="0-4-CallBack-Function-in-Java-搜Subtype-Polymorphism-vs-HoFs"><a href="#0-4-CallBack-Function-in-Java-搜Subtype-Polymorphism-vs-HoFs" class="headerlink" title="0. 4 CallBack Function in Java(搜Subtype Polymorphism vs. HoFs)"></a>0. 4 CallBack Function in Java(搜Subtype Polymorphism vs. HoFs)</h3><ol>
<li>实现机制:过接口或抽象类实现，允许程序将一个方法作为参数传递给另一个方法，或者在某个事件或条件发生时触发一个方法的执行</li>
<li>涉及内容:接口、匿名类、lambda、函数式接口、事件监听器、回调机制</li>
</ol>
<h3 id="0-5-Nested-Class与Interface的访问控制级别"><a href="#0-5-Nested-Class与Interface的访问控制级别" class="headerlink" title="0. 5 Nested Class与Interface的访问控制级别"></a>0. 5 Nested Class与Interface的访问控制级别</h3><ol>
<li>补充一下默认访问级别——有指定访问修饰符，它具有默认访问级别。这意味着接口只能被同一个包中的其他类访问，不能被不同包中的类访问</li>
</ol>
<h3 id="0-6-How-to-deal-with-Exceptions"><a href="#0-6-How-to-deal-with-Exceptions" class="headerlink" title="0. 6 How to deal with Exceptions"></a>0. 6 How to deal with Exceptions</h3><ol>
<li><p>异常类型</p>
<ol>
<li>检查型异常（Checked Exceptions）：这些是编译时检查的异常</li>
<li>非检查型异常（Unchecked Exceptions）：这些是编译时不检查的异常</li>
<li>错误error：通常是由于系统资源限制或编程中的严重问题导致的，它们不属于 Exception 类的子类</li>
</ol>
</li>
<li><p>抛出异常</p>
<ol>
<li>throw：手动抛出异常</li>
<li>throws：在方法声明中指定该方法可能抛出的异常<code>public void readFile(String filePath) throws IOException &#123; ... &#125;</code>当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常——try-catch<ol>
<li>告知外部代码此处有可能有异常，需要进行处理</li>
</ol>
</li>
</ol>
</li>
<li><p>try-catch</p>
<ol>
<li>可以有多重</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// code that would go wrong ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   <span class="comment">// code to deal with the exceptions ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException f) &#123;</span><br><span class="line">   <span class="comment">// code to deal with ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>try-with-resources</p>
</li>
</ol>
<h3 id="0-7-Set-of-E…-方法用于可以直接进行初始化"><a href="#0-7-Set-of-E…-方法用于可以直接进行初始化" class="headerlink" title="0. 7 Set.of(E…)方法用于可以直接进行初始化"></a>0. 7 Set.of(E…)方法用于可以<strong>直接</strong>进行初始化</h3><ol>
<li><p>HashSet的构造函数不可以直接传入内容，比较麻烦，Set.of方法返回则不可修改，也可以用于自定义的Set等</p>
</li>
<li><p>of function：静态、泛型</p>
<ol>
<li>可变量参数会被自动打包到数组中</li>
<li><code>public static ArraySet&lt;T&gt; of(T... stuff)</code>不可行——T 被视为类级别的类型参数。然而，在静态方法中，类级别的类型参数是不可访问的，因为静态方法属于类，而不是类的实例。因此，编译器无法识别 T 是什么类型，从而导致编译错误</li>
<li>&lt;T&gt; 放在返回类型之前，表明这个方法是泛型方法，可以处理任意类型 T。这个声明告诉Java编译器，T 是这个方法的类型参数。它允许方法根据传入的参数确定类型 T</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ArraySet&lt;T&gt; <span class="title function_">of</span><span class="params">(T... stuff)</span> &#123;</span><br><span class="line">   <span class="comment">/** 使用了可变量参数 */</span></span><br><span class="line">   ArraySet&lt;T&gt; returnSet = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (T t: stuff) &#123;</span><br><span class="line">      returnSet.add(t);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> returnSet;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-Basic-Classes-and-Testing"><a href="#1-Basic-Classes-and-Testing" class="headerlink" title="1. Basic Classes and Testing"></a>1. Basic Classes and Testing</h2><h3 id="1-1-Defining-and-Using-Classes"><a href="#1-1-Defining-and-Using-Classes" class="headerlink" title="1. 1 Defining and Using Classes"></a>1. 1 Defining and Using Classes</h3><ol>
<li>using helper functions, eaiser to debug and so on</li>
<li>static and nonstatic</li>
</ol>
<h3 id="1-2-Testing"><a href="#1-2-Testing" class="headerlink" title="1. 2 Testing"></a>1. 2 Testing</h3><ol>
<li><p>Tools:使用junit进行测试</p>
</li>
<li><p><strong>Running:运行测试</strong></p>
<ol>
<li><p>一可以在main中运行</p>
</li>
<li><p>二可以使用@org.junit.Test，方法需要为non-static，使用@Test</p>
<ol>
<li>使用”test annotation”来便于测试</li>
<li>使用import进行省略，后续会拓展</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test; </span><br><span class="line">   <span class="comment">// 使用这个之后就可以使用@Test来使用junit运行测试而不是main了</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Test Driven Development(TDD)，先编写Test再完成它而不是先完成再编写Test</p>
</li>
<li><p>unit test and intergration test</p>
</li>
</ol>
<h2 id="2-Lists-Introduction"><a href="#2-Lists-Introduction" class="headerlink" title="2. Lists(Introduction)"></a>2. Lists(Introduction)</h2><h3 id="2-1-References-Recursion-and-Lists"><a href="#2-1-References-Recursion-and-Lists" class="headerlink" title="2. 1 References,Recursion,and Lists"></a>2. 1 References,Recursion,and Lists</h3><ol>
<li>references引用<ol>
<li>java中的普通类型在内存中存储为变量的”value”，java中的数组是对象</li>
<li>java中的引用都是复制，只是地址还是内容而已，<strong>一个对象存储的是存储的地址</strong></li>
<li>java中的引用(无论什么object都是8bytes)存储了对某个对象的引用(内存地址)，强调”object”(与cpp不同)<ol>
<li><code>Obj _obj = new Obj();</code>中_obj存储地址指向<code>new Obj()</code>开辟的内存空间</li>
<li>java中的&#x3D;都是复制，但是<code>Obj _obj2 = _obj</code>时复制的是地址，表现就是指向同一个地址</li>
</ol>
</li>
</ol>
</li>
<li>Lists即为链表，java实现，并使用递归和迭代版本实现<ol>
<li>java中的链表可以在内部使用本对象进行指向，这是因为java中的reference</li>
</ol>
</li>
</ol>
<h3 id="2-2-SLLists-Nested-Classes-Sentinel-Nodes"><a href="#2-2-SLLists-Nested-Classes-Sentinel-Nodes" class="headerlink" title="2. 2 SLLists, Nested Classes, Sentinel Nodes"></a>2. 2 SLLists, Nested Classes, Sentinel Nodes</h3><ol>
<li>SLLists<ol>
<li>一:IntList是裸递归，没有优化，二:IntList没有对成员进行访问控制，三:可以隐藏null的细节</li>
<li>使用SLList作为用户与node的中间人，进行抽象进行组织</li>
</ol>
</li>
<li><strong>Nested Classes(嵌套类)</strong><ol>
<li>Java 为我们提供了将类声明嵌入到另一个类声明中的能力，嵌套类对代码性能没有有意义的影响</li>
<li>静态嵌套类(Static Nested Class)<ol>
<li>法则：如果不使用外部类的任何实例成员，请使嵌套类成为静态类</li>
<li>静态嵌套类是定义在另一个类中，并且使用 static 关键字声明的类，与成员内部类不同，静态嵌套类不能直接访问外部类的非静态成员它们可以看作是外部类的一个独立组件，通常用于工具类或辅助类</li>
<li>可以独立于外部类的实例而使用，可以独立创建实例</li>
</ol>
</li>
</ol>
</li>
<li><strong>Container设计原则</strong><ol>
<li>隐藏细节(helper使用private，static类)，接口函数的具体helper实现使用private进行隐藏</li>
<li>使用caching避免不必要的开销</li>
</ol>
</li>
<li>Sentinel Node(哨兵节点)<ol>
<li>起源：使用空链表问题，再次进行addList</li>
<li>为特殊节点进行特殊考虑的方法<ol>
<li>使用if else进行抉择</li>
<li>私用哨兵节点</li>
</ol>
</li>
<li>解释：一个入口，可以避免特殊情况进行实现</li>
</ol>
</li>
<li>不变量Invariant<ol>
<li>不变量（Invariant） 是指在特定操作或一系列操作过程中始终保持为真的陈述或条件</li>
<li>可以是设计上的要求，也可以是思路上的实现，抓住这几个就不会错，概念问题</li>
</ol>
</li>
</ol>
<h3 id="2-3-DLLists-Arrays"><a href="#2-3-DLLists-Arrays" class="headerlink" title="2. 3 DLLists, Arrays"></a>2. 3 DLLists, Arrays</h3><ol>
<li><strong>SLList的缺点</strong><ol>
<li>即使添加Invariant _last还是很难removeLast()，因为难以找到前一个指向它的点，是Single单向的</li>
</ol>
</li>
<li>DLList<ol>
<li><strong>哨兵节点</strong><ol>
<li>double sentinel:夹在中间</li>
<li>circular sentinel approach:变成环状，前后哨兵指向同一个</li>
<li>具体实现——project1</li>
</ol>
</li>
</ol>
</li>
<li><strong>Generic泛型</strong><ol>
<li>泛型只适用于引用类型，不能将int&#x2F;double而是应该适用引用版本Integer等——要在基元类型上实例化泛型，请使用 Integer、Double、Character、Boolean、Long、Short、Byte 或 Float 而不是它们的基元等效项</li>
<li>详见project1会的</li>
</ol>
</li>
<li>Array<ol>
<li><p>三种创建方式——可以直接省略new，但是长度由元素定，适用{}</p>
</li>
<li><p>Java 数组仅在运行时执行边界检查。也就是说，以下代码编译良好，但在运行时会崩溃</p>
</li>
<li><p>复制数组</p>
<ol>
<li><code>System.arraycopy(b,0,x,3,2);</code></li>
<li>适用for循环进行赋值</li>
</ol>
</li>
<li><p><strong>2D array</strong></p>
<ol>
<li><p>java中的引用都是copy，值不同，copy的值也不同，包括内容，比如</p>
<ol>
<li>java中二维数组在高纬度也是存储数组对象的地址(对对象使用引用)</li>
<li>此处row0最终还是null是因为一开始test[0]处存储的地址是null而不是后续new出来的地址，故row0一直为null</li>
<li>row02中就会随改变2而改变</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dArrayTest</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>[][] test;</span><br><span class="line">   test = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">   <span class="type">int</span>[] row0 = test[<span class="number">0</span>];</span><br><span class="line">   test[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">   <span class="type">int</span>[] row02 = test[<span class="number">0</span>];</span><br><span class="line">   test[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>反射：可以在运行时指定所需的字段<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html">资料</a></p>
</li>
<li><p>the maximum number of array boxes that Java will track at any given time——Java虚拟机(JVM)并没有对数组盒子（array boxes）跟踪数量设定硬性限制，但是数组的大小受到JVM可用内存和平台的限制。由于数组的索引是int类型，理论上数组可以有的最大元素数量是2^31 - 1，即2,147,483,647个元素。然而，实际上，创建数组时可能会受到JVM设置的限制，比如可以使用的堆内存大小，或者JVM对数组大小的内部限制</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-ALists-Resizing"><a href="#2-4-ALists-Resizing" class="headerlink" title="2. 4 ALists, Resizing"></a>2. 4 ALists, Resizing</h3><ol>
<li>ALists<ol>
<li>Resizing:(好像是false的)<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Resizing.jpg" alt="math prove"><ol>
<li>变大的同时也要变小，减小内存浪费</li>
<li>变小使用usage ratio&#x3D;size&#x2F;arrsize</li>
</ol>
</li>
</ol>
</li>
<li>Generic AList<ol>
<li>Problem1:无法直接创建泛型对象的数组<ol>
<li>Reason:Java在编译时会进行类型擦除，即泛型类型信息在编译后被移除，运行时Java无法确保泛型数组的类型安全，因此禁止直接创建泛型数组</li>
<li>Solution:<code>T[] items = (T[])new Object[8];</code>创建一个Object类型的数组，然后将其强制转换为泛型类型的数组—未经检查的强制转换”警告，因为编译器无法验证这种转换的安全性。尽管如此，在需要使用泛型数组的情况下，这种方法是Java中常见的解决方案</li>
</ol>
</li>
<li>Problem2:防止“悬空对象”(Loitering)<ol>
<li><p>Reason:在Java中，当对象不再被引用时，垃圾回收器会自动销毁这些对象。如果你在删除数组元素后没有将其引用设置为null，该对象仍然在内存中有引用，垃圾回收器就不会回收它</p>
</li>
<li><p>Solution</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        elements[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里我们没有将弹出的元素设置为null</span></span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>(<span class="number">10</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        stack.pop(); <span class="comment">// 弹出3</span></span><br><span class="line">        stack.pop(); <span class="comment">// 弹出2</span></span><br><span class="line">        <span class="comment">// 虽然2和3已经弹出，但它们仍然保留在数组中，无法被垃圾回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 解决方法 */</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// 将弹出的元素引用设置为null</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-Futher-Java-Feature"><a href="#3-Futher-Java-Feature" class="headerlink" title="3. Futher Java Feature"></a>3. Futher Java Feature</h2><h3 id="3-1-Inheritance-Implements"><a href="#3-1-Inheritance-Implements" class="headerlink" title="3. 1 Inheritance, Implements"></a>3. 1 Inheritance, Implements</h3><ol>
<li>Reason:method overloading is ugly and inconvenient</li>
<li>接口：一个合同，指定了列表必须能够做什么，但它没有为这些行为提供任何实现<ol>
<li>@Override为重写tag，会在编译时补充错误信息，如果getLast()写出getLsat()会报错</li>
</ol>
</li>
<li><strong>default和override方法</strong>，java使用dynamic method selection—当 Java 运行一个被覆盖的方法时，它会在其动态类型中搜索适当的方法签名并运行它，但是并不适用于重载overload而是override<ol>
<li>在重载overload中，只会检查静态类型</li>
</ol>
</li>
<li>interface inheritance &amp;&amp; implementation inheritance<ol>
<li><strong>接口继承</strong>指的是一个接口可以继承另一个或多个接口。这允许接口扩展或包含其他接口中定义的方法和常量——接口允许多继承</li>
<li><strong>实现继承</strong>指的是一个类继承另一个类，从而获得其属性和方法。这是类之间的一种“是一个（is-a）”关系——类只能单继承</li>
</ol>
</li>
<li><strong>潜在问题</strong>:<ol>
<li>如果两个接口给出冲突的默认方法，无法自动调用，需要手动处理——override、显式选择、合并</li>
</ol>
</li>
<li><strong>实践出真知</strong><ol>
<li>接口只可以调用接口的方法，如果想要在接口中访问实现该接口类的变量，需要适用get()方法</li>
<li>泛型接口只能由泛型类进行实现</li>
</ol>
</li>
</ol>
<h3 id="3-2-Extends-Casting-Higher-Order-Functions"><a href="#3-2-Extends-Casting-Higher-Order-Functions" class="headerlink" title="3. 2 Extends, Casting, Higher Order Functions"></a>3. 2 Extends, Casting, Higher Order Functions</h3><ol>
<li><p>extends(使用VengefulSLList说明):继承，子类将继承父类的全部成员(包括嵌套类)</p>
<ol>
<li><p>使用super.来使用直接父类方法——NOTICE:Java没有多类继承(没有父类的父类)</p>
<ol>
<li>solution:接口&#x2F;低层-&gt;高层转换</li>
</ol>
</li>
<li><p>构造函数无法继承，但 Java 要求所有构造函数都必须从调用其超类的构造函数之一开始——可以指定你想要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VenegefulSLList</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">super</span>(); <span class="comment">// 如果不调用则java自动为我们调用超类的无参数构造函数</span></span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>The Object Class</p>
<ol>
<li>Java 中的每个类都是 Object 类的后代，或者是 Object 类的扩展。即使在其类中没有显式扩展的类，也仍然隐式扩展 Object 类</li>
<li>通用方法<ol>
<li>equals(Object obj)：用于比较两个对象是否相等</li>
<li>hashCode()：返回对象的哈希码，通常与equals()方法配合使用</li>
<li>toString()：返回对象的字符串表示，通常用于调试</li>
<li>clone()：创建并返回对象的一个副本</li>
</ol>
</li>
<li>提供放射&#x2F;序列化功能</li>
</ol>
</li>
<li><p>Encapsulation 封装</p>
<ol>
<li>modular, interchangeable</li>
<li>“Design for change”</li>
<li>hiding information</li>
<li>NOTICE:How Inheritance Breaks Encapsulation<ol>
<li>内部对外隐藏了细节但是实现互相调用可能导致死循环</li>
</ol>
</li>
</ol>
</li>
<li><p>Type Checking and Casting</p>
<ol>
<li>Type Checking<ol>
<li>编译器进行的是静态的检查，不会允许向下的类型转换</li>
</ol>
</li>
<li>Casting<ol>
<li>强制转换—告诉编译器特定表达式具有特定的编译时类型</li>
<li>这是一个危险的东西</li>
</ol>
</li>
</ol>
</li>
<li><p>Higher Order Functions 高阶函数</p>
<ol>
<li>before java 8<ol>
<li><p>java8以前没有函数类型，需要借助接口和类来实现—接口是Java中的一等公民，是引用类型的一个例子。这意味着接口类型的对象可以被变量引用、传递给方法、作为返回值等</p>
</li>
<li><p>java接口本身不能被直接实例化。接口是引用类型，但它仅包含抽象方法(除非是默认方法或静态方法，这些可以在Java 8及以后版本中定义在接口中)和常量(不可以是实例变量)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** IIntUnaryFunction.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tenx.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tenx</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x*<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** HOF.java (anything, just for test)*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HOF</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f.apply(f.apply(value));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">IntUnaryFunction</span> <span class="variable">tenx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tenx</span>();</span><br><span class="line">      System.out.println(do_twice(tenx,value));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-3-Subtype-Polymorphism-vs-HoFs"><a href="#3-3-Subtype-Polymorphism-vs-HoFs" class="headerlink" title="3. 3 Subtype Polymorphism vs. HoFs"></a>3. 3 Subtype Polymorphism vs. HoFs</h3><ol>
<li>Subtype polymorphism，也称为静态多态性或包含多态性，允许一个引用类型可以指向其任何子类型的对象。这种多态性在编译时就已经确定，因此得名“静态”</li>
<li>Problem1:类似于&gt;号比较符号无法对所有类型成立，比如String，无法直接在<code>public static Object max(Object[] items)</code>中进行<code>items[i] &gt; items[maxDex]</code>的比较<ol>
<li>Solution:使用interface的继承来实现<ol>
<li>详见idea代码DSAImplement的…SP和…SP1</li>
<li>…SP不完美——需要强制转换；没有耦合好(built-in interface)</li>
<li>…SP1利用所有已经存在的库并使用 Comparable</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/comparable.png" alt="comparable"></li>
</ol>
</li>
<li>对于java，已经内置实现了Comparable</li>
</ol>
</li>
<li>Problem2:如何使用多种顺序来进行比较?——Comparator in java(built-in)<ol>
<li>回调概念：有时候，一个函数可能需要另一个函数的帮助来完成它的任务，而这个帮助函数可能还没有被编写（例如，一个比较最大值的函数可能需要compareTo方法）。所谓的回调函数就是提供帮助的那个函数（在这个场景中是compareTo）——此处是回调是因为当Arrays.sort()或类似的排序方法被调用时，它们会使用传递给它们的Comparator实例的compare方法来确定元素的顺序</li>
</ol>
</li>
<li><strong>SUM UP总结一下</strong><ol>
<li><p>子类多态:强调的是子类对象可以被当作父类对象来处理，而具体的行为则由子类的实际类型决定——和运行时多态(Runtime Polymorphism)这两个术语在面向对象编程中经常被提及，它们描述了多态性的不同方面，但通常指的是相同的概念(可以互换)</p>
</li>
<li><p>Interface Compare和Interface Comparator都是Java中built-in的比较&#x2F;排序接口——二者都是泛型</p>
<ol>
<li><p>Comparable接口用于让类的对象具有“自然顺序”（Natural Ordering）——适合在一个类中实现一个默认的排序逻辑（如按分数排序）</p>
<ol>
<li>通过实现类的对象使用的</li>
<li>找到最大值可以用父类Comparable来作为引用，后续再强制转换，也可以利用T，后面再讲</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 接口是什么样的 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** How to use? */</span></span><br><span class="line"><span class="comment">// 1. 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">implements</span> <span class="title class_">Comparabel</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T obj)</span>&#123;</span><br><span class="line">      <span class="comment">// 自定义逻辑...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 可以根据此排序来实现其他功能比如找到最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Maximizer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">max</span><span class="params">(Comparable[] items)</span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 最终使用 main function 中</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) Maximizer.max(dogs);</span><br><span class="line">   <span class="comment">// 如果不要强制转换的方式可以问gpt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Comparator接口用于定义多个排序规则，或者在无法修改类时定义排序规则。你可以创建不同的Comparator实现来定义不同的排序逻辑</p>
<ol>
<li>通过omparator对象自定义比较顺序和使用的</li>
<li>常常使用静态嵌套类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 接口是什么样的 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;            </span><br><span class="line"></span><br><span class="line"><span class="comment">/** How to use */</span></span><br><span class="line"><span class="comment">// 1. 导入包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator</span><br><span class="line"><span class="comment">// 2. 进行实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;T&gt;&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span><span class="params">(ClassName o1, ClassName o2)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 使用 main function 中</span></span><br><span class="line"><span class="type">NameComparator</span> <span class="variable">nc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line"><span class="keyword">if</span>(nc.compare(o1,o2))&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>一般不进行实现自己的OurCompare，因为已经有现成的了，整合性和耦合性高——集成到Collection.sort(dogs)之类的</p>
</li>
</ol>
</li>
</ol>
<h3 id="3-4-Java-Packages-and-Library-gitbook"><a href="#3-4-Java-Packages-and-Library-gitbook" class="headerlink" title="3. 4 Java Packages and Library(gitbook)"></a>3. 4 Java Packages and Library(gitbook)</h3><ol>
<li><p>Java Libraries</p>
<ol>
<li><p>Java 具有某些内置的 Abstract 数据类型可供您使用。它们都打包在 Java 库中</p>
</li>
<li><p>List(ArrayList), Set(HashSet), Map(HashMap) 三个重要的adts都在java.util中</p>
<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/collection_hierarchy.png" alt="collection"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** How to Use them? */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. List, in Words.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getWords</span><span class="params">(String input_filename)</span>&#123;</span><br><span class="line">   List&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">In</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">In</span>(); <span class="comment">// 特殊语法</span></span><br><span class="line">   <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">      lst.add(in.readString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Set, in Words.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countUnique</span><span class="params">(List&lt;String&gt; words)</span>&#123;</span><br><span class="line">   Set&lt;String&gt; ss = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">      ss.add(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ss.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Map, in Words.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title function_">collectWordsCount</span><span class="params">(List&lt;String&gt; words)</span>&#123;</span><br><span class="line">   Map&lt;String, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (String s: target) &#123;</span><br><span class="line">      counts.put(s, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String s: words) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counts.contain(s))&#123;</span><br><span class="line">         counts.put(word,counts.get(s)+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Interface and Abstract Class</p>
<ol>
<li>Interface品质：公开、无法实例化、无默认实现的方法都是抽象的</li>
<li>抽象类：可以具有成员变量、方法可公共可私有、默认方法具体除非抽象、不可以实例化</li>
<li>区别<ol>
<li>抽象类可以有构造方法。接口不能有构造方法</li>
<li>一个类只能继承一个抽象类（单继承）。一个类可以实现多个接口（多继承）</li>
<li>抽象类中的成员可以有各种访问修饰符，如public、protected、private等。接口中的成员默认是public的，不能使用其他访问修饰符</li>
<li>接口是“can-do”，抽象类是“is-a”</li>
</ol>
</li>
</ol>
</li>
<li><p>Package</p>
<ol>
<li>概念：在Java中，包（Package）是一种组织和管理类的方式，它有助于将功能相关的类和接口组织在一起，形成逻辑上的分组—包提供了一种命名空间，使得不同包中的类可以使用相同的名称而不会发生冲突</li>
<li>使用import导入包，在.java文件顶部声明package(一般对应目录结构)</li>
<li><strong>默认包</strong>：没有显式声明的文件都在默认包中<ol>
<li>Notice:无法导入默认包中的代码，并且可能会意外地在默认包下创建具有相同名称的类</li>
</ol>
</li>
<li>package特点<ol>
<li>包的可见性：包中的类默认是包级私有的，这意味着它们只能在同一个包中被访问</li>
<li>包的层次结构：包可以有层次结构，例如com.example.myapp.utils表示com.example.myapp包下的一个子包</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-5-Exceptions-Iterators-Object-Methods"><a href="#3-5-Exceptions-Iterators-Object-Methods" class="headerlink" title="3. 5 Exceptions, Iterators, Object Methods"></a>3. 5 Exceptions, Iterators, Object Methods</h3><ol>
<li>Throwing Exceptions<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/checked_exceptions.png" alt="异常种类"></li>
<li>java中的异常是对象<code>throw new someExceptions();</code></li>
<li>当一个异常发生时，如果它被正确地捕获并处理，程序可以继续执行；如果一个异常没有被处理，它将向上传播到调用栈，直到被处理或到达主方法（main 方法），此时程序将终止</li>
</ol>
</li>
<li>Iterators<ol>
<li>几乎所有实现了 Collection 接口的类（如 List、Set 等）都实现了Iterator接口<ol>
<li>java.lang中的iterable&lt;T&gt;指定了一个方法iterator()</li>
<li>java.util中的iterator&lt;T&gt;指定了hasNext()和next()两种方法</li>
</ol>
</li>
<li>for增强型语句会使用iterator，可以通过覆写给定的接口来自定义</li>
<li>注意点<ol>
<li>通过iterator()获取内部private嵌套类</li>
<li>自己implement iterator&lt;T&gt;时的ArraySet无需泛型，这里就是一个自定义的类型</li>
</ol>
</li>
<li>代码见MyIterable</li>
</ol>
</li>
<li>Object Methods<ol>
<li><p>toString()</p>
<ol>
<li>System.out.println（） 函数在传递给它的任何对象上隐式调用此方法，并打印返回的字符串</li>
<li>我们可以进行覆写!——使用StringBulider就很好了，bouns中的不太好，但是可以作为<code>String.join()</code>的参考<code>return String(&quot;, &quot;,my_list);</code>返回的是一个String</li>
</ol>
</li>
<li><p>equal()</p>
<ol>
<li><p>&#x3D;&#x3D;与!&#x3D;对基元primitives检查值是否相等，对引用检查地址是否相等，所以需要equal()</p>
</li>
<li><p>一些规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 等价：反身，对称，传递</span></span><br><span class="line"><span class="comment"> * 2. x.equals(null)必须返回null，自己null检查</span></span><br><span class="line"><span class="comment"> * 3. 类型转换</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>getClass()</p>
<ol>
<li><p>直接上使用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的全名（包括包名）</span></span><br><span class="line">Class&lt;?&gt; class_type = myobj.getClass();</span><br><span class="line">System.out.println(class_type.getName())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行比较</span></span><br><span class="line"><span class="keyword">if</span> (class_type.equals(obj.getClass())) &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-6-JAR-FILE-gitbook"><a href="#3-6-JAR-FILE-gitbook" class="headerlink" title="3. 6 JAR FILE(gitbook)"></a>3. 6 JAR FILE(gitbook)</h3><ol>
<li>程序将包含多个 .class 文件。如果您想共享此程序，而不是共享特殊目录中的所有 .class 文件，您可以通过创建 JAR 文件将所有文件“压缩”在一起。这个单.jar文件将包含您的所有 .class 文件，以及<strong>其他一些附加信息</strong></li>
<li>JAR 文件就像 zip 文件一样。完全可以将文件解压缩并转换回.java文件。JAR 文件不能保证您的代码安全，因此您不应与其他学生共享您的项目.jar文件</li>
</ol>
<h3 id="3-7-Access-Control-gitbook"><a href="#3-7-Access-Control-gitbook" class="headerlink" title="3. 7 Access Control(gitbook)"></a>3. 7 Access Control(gitbook)</h3><ol>
<li>Package Private：Java中，如果一个类的成员（如变量、方法）没有显式地声明为 public、protected 或 private，那么这个成员将默认拥有包私有（Package-Private）访问权限。包私有的意思是：<ol>
<li>同一包内的类 可以访问这些成员。</li>
<li>包外的类 不能访问这些成员，即使它们是该类的子类</li>
</ol>
</li>
<li>Interface Public：对于接口，其方法的默认访问实际上是 public，且访问仅取决于静态类型(不考虑动态类型)</li>
<li>针对java的member<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/access_modifiers.png" alt="java访问控制"></li>
</ol>
</li>
</ol>
<h3 id="3-8-Generic-and-AutoBoxing-gitbook"><a href="#3-8-Generic-and-AutoBoxing-gitbook" class="headerlink" title="3. 8 Generic and AutoBoxing(gitbook)"></a>3. 8 Generic and AutoBoxing(gitbook)</h3><ol>
<li><p>autoboxing</p>
<ol>
<li>Java 可以在原始类型(8种)和包装器类型之间隐式转换</li>
<li>Notice<ol>
<li>Arrays are never autoboxes or auto-unboxed：int[] x地址与integer[] y地址不可以赋值</li>
<li>依赖于自动装箱和取消装箱的代码将比避免此类自动转换的代码慢</li>
<li>包装类型比基元类型使用更多的内存：不仅您的代码必须包含对对象的 64 位引用，而且每个对象还需要 64 位开销用于存储对象的动态类型等内容</li>
</ol>
</li>
<li>automatically widen a primitive<ol>
<li>小转大会自动转(double d)传入int i等效于(double) i</li>
<li>较宽的类型转到较窄的类型，则必须手动强制转换</li>
</ol>
</li>
</ol>
</li>
<li><p>auto boxing 导致的错误</p>
<ol>
<li><p>Problem</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">   ArrayMap&lt;Integer, Integer&gt; am = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">   am.put(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">   assertEquals(expected, am.get(<span class="number">2</span>)); <span class="comment">// 这一行会错误</span></span><br><span class="line">   <span class="comment">// solution</span></span><br><span class="line">   <span class="comment">// assertEquals(expected, (int) am.get(2));</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* REASON</span></span><br><span class="line"><span class="comment">    * assertEquals(int expected, int actual)</span></span><br><span class="line"><span class="comment">    * assertEquals(Object expected, Object actual)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>generic methods</p>
<ol>
<li>与泛型类区别<ol>
<li>泛型类：在类级别定义类型参数，这些类型参数在整个类的范围内都可以使用。</li>
<li>泛型方法：在方法级别定义类型参数，这些类型参数仅在方法的范围内有效</li>
</ol>
</li>
<li>Grammar<code>public static &lt;T&gt; T get(List&lt;T&gt; lst);</code>&lt;T&gt;用于指定类型参数</li>
</ol>
</li>
<li><p>Type Upper Bounds</p>
<ol>
<li>Problem：在4. 1中maxKey(OurMap&lt;K,V&gt; map)中进行比较的Problem：并非所有对象都有CompareTo和&gt;&lt;</li>
<li>类型上界（Type Upper Bounds）是Java泛型中的一种机制，允许你在泛型类型参数中指定类型的上限。这意味着你可以限制泛型类型参数所能接受的类型，确保泛型方法或类只适用于某些特定的类型或其子类型</li>
<li>Grammar<ol>
<li><code>public &lt;T extends SuperClass&gt; void someMethod(T param)</code></li>
<li><code>public static &lt;K extends Comparable&lt;K&gt;, V&gt; K maxKey(Map61B&lt;K, V&gt; map) &#123;...&#125;</code></li>
<li>可以是接口(也是extends不是implements)&#x2F;类——当与泛型一起使用时（如在泛型方法头中），extends 会施加约束，而不是授予新的能力</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-Abstraction-ADTs-and-Asymtotics-Annlysis"><a href="#4-Abstraction-ADTs-and-Asymtotics-Annlysis" class="headerlink" title="4. Abstraction, ADTs and Asymtotics Annlysis"></a>4. Abstraction, ADTs and Asymtotics Annlysis</h2><h3 id="4-1-OurMap-gitbook"><a href="#4-1-OurMap-gitbook" class="headerlink" title="4. 1 OurMap(gitbook)"></a>4. 1 OurMap(gitbook)</h3><ol>
<li>这个是5. 3的，很奇怪这里是叫我们实现自己的map(simple)<ol>
<li>代码详见Map61b</li>
</ol>
</li>
<li>auto boxing导致的问题见3. 8</li>
</ol>
<h3 id="4-2-Encapsulation-API’s-ADT’s"><a href="#4-2-Encapsulation-API’s-ADT’s" class="headerlink" title="4. 2 Encapsulation, API’s, ADT’s"></a>4. 2 Encapsulation, API’s, ADT’s</h3><ol>
<li><p><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/collection_hierarchy.png" alt="collection"></p>
</li>
<li><p>Encapsulate 封装</p>
<ol>
<li>Module模块：一组方法，它们作为一个整体协同工作，以执行某些任务或一组相关任务</li>
<li>封装：如果模块的实现是完全隐藏的，则称其为封装模块，并且只能通过记录的接口访问它</li>
</ol>
</li>
<li><p>API（应用程序编程接口）</p>
</li>
<li><p>ADT（抽象数据结构）是由其行为定义的高级类型，而不是由其实现定义的高级类型——可以从接口来看</p>
<ol>
<li><p>在 Java 中，Deque 被称为接口。从概念上讲，我们将 deque 称为 Abstract 数据类型。Deque 只带有行为，而没有任何具体的方式来展示这些行为。这样，它就是抽象的</p>
</li>
<li><p><em><strong>使用已有实现DS构造ADT</strong></em>：List&lt;T&gt;做出Stack</p>
<ol>
<li>委托和继承一般可以互换：委托是指您不想将当前类视为您从中提取方法的类的一个版本——is-a，has-a</li>
<li>Adapter明显使用依赖注入的方式，自定义程度较高</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. Extends 继承 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> &#123;</span><br><span class="line">      add(x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 2. Delegation: has-a list */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;T&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">      lst.add(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 3. Adapter: Seperate inject */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> List lst;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">StackAdapter</span><span class="params">(List&lt;T&gt; worker)</span> &#123;</span><br><span class="line">      lst = worker;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> &#123;</span><br><span class="line">      lst.add(t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些常用的adts</p>
<ol>
<li>堆栈：支持元素后进先出检索的结构</li>
<li>列表：一组有序的元素</li>
<li>Sets ：一组无序的唯一元素（无重复）</li>
<li>映射：键&#x2F;值对集</li>
</ol>
</li>
</ol>
</li>
<li><p>View</p>
<ol>
<li><p>作用：视图（Views）是对现有对象的一种替代表示。视图本质上限制了用户对底层对象的访问权限。通过视图进行的修改会影响到实际的底层对象</p>
</li>
<li><p>例子：List&lt;String&gt;子类的subList()返回的SubList&lt;T&gt;是原列表的一个视图，包含了对源列表的引用，并使用“指针”进行标记</p>
<ol>
<li>举的例子是进行反转</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Item&gt; <span class="title function_">sublist</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">   Return <span class="keyword">new</span> <span class="title class_">this</span>.Sublist(start,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private <span class="keyword">class</span> <span class="title class_">Sublist</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;Item&gt;&#123;</span><br><span class="line">    Private <span class="type">int</span> start end;</span><br><span class="line">    Sublist(inst start, <span class="type">int</span> end)&#123;...&#125;</span><br><span class="line">    <span class="comment">// 需要指向同一个列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>View与API进行结合——通用的反转方法，通过使用subList()方法使得反转API连贯</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-3-Asymptotics-I-II"><a href="#4-3-Asymptotics-I-II" class="headerlink" title="4. 3 Asymptotics I II"></a>4. 3 Asymptotics I II</h3><ol>
<li>比较算法效率，Math Methods<ol>
<li>The key<ol>
<li>Abstraction: dropping lower order terms and multiplicative constants</li>
<li>only care about the order of growth of R(N) -&gt; f(N)</li>
</ol>
</li>
<li>Trick and Principles<ol>
<li>ONE: Consider only the Worst Case -&gt; N approaches infinity</li>
<li>TWO: Restrict Attention to One Operation -&gt; Eliminate Low Order Terms</li>
<li>THREE: Eliminate Multiplicative Constants</li>
</ol>
</li>
</ol>
</li>
<li>arbitrary units of time(AU): 任意时间单位</li>
<li>Big-Theta: Fixing Uncertainty with Boundaries<ol>
<li>K1*f(n) &lt; R(N) &lt; K2*f(n) 给定K1、K2，在一定范围内成立，同理，可以调整K1、K2来调整范围</li>
<li>也可以理解为“夹逼”</li>
<li>Describing runtime with both an upper and lower bound can informally be though of as runtime “equality”.</li>
</ol>
</li>
<li>Big-O: less than or equal, upper bounded<ol>
<li>Big-O don’t care the lower bound</li>
<li>R(N) &lt;&#x3D; K2*f(n)</li>
</ol>
</li>
<li>让分析更快、更准<ol>
<li>计算操作数量，可用~来表示大致</li>
<li><strong>集合图形法</strong>：几次循环用几维，面积图形</li>
<li><strong>C(n)-n</strong>：图可以看出<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Comlicated_Counting.jpg" alt="cs61b中的题"></li>
</ol>
</li>
<li><strong>增量方法</strong>：将 1 添加到 N 时，我们需要完成的工作量就会增加一倍，则是2^n</li>
<li>记住一些常用的<ol>
<li>上面图就是一个例子，思想可以利用到摊销那里(折线化直)</li>
<li>递归recursion<ol>
<li>特点：树状，2^n:将 1 添加到 N 时，我们需要完成的工作量就会增加一倍</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/asymptotics2_tree2.png" alt="recursion"></li>
<li>Math Way: C(1) &#x3D; 1, C(2) &#x3D; 1 + 2*C(1), C(3) &#x3D; 1 + 2*C(2), C(N) &#x3D; 1 + 2*C(n-1)——其中的root是1</li>
</ol>
</li>
<li>binary search<ol>
<li>特点：树状</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/static_binary_search.png" alt="static"></li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/bs_total.jpg" alt="total"> fix: not array sorting but find one in the array</li>
</ol>
</li>
<li>merge sort: sort using 二分法<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/ms_total.jpg" alt="total"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-4-Omega-and-Amortized-Analysis-gitbook"><a href="#4-4-Omega-and-Amortized-Analysis-gitbook" class="headerlink" title="4. 4 Omega and Amortized Analysis(gitbook)"></a>4. 4 Omega and Amortized Analysis(gitbook)</h3><ol>
<li>Big Theta limitation:  if the runtime depends on more than just the size of the input, then we must qualify our statements into different cases before using Big Theta – use Big O<ol>
<li>酒店最贵的房间是每晚639美元 – Big Theta</li>
<li>酒店每间客房每晚低于或等于 639 美元 – Big O<ol>
<li>Big O is NOT the same as “worst case”. But it is often used as such, it only means upper bound</li>
</ol>
</li>
</ol>
</li>
<li>When or Why we use Big-O<ol>
<li>It allows us to make simple statements without case qualifications, in cases where the runtime is different for different inputs.</li>
<li>Sometimes, for particularly tricky problems, we (the computer science community) don’t know the exact runtime, so we may only state an upper bound.</li>
<li>It’s a lot easier to write proofs for Big O than Big Theta, like we saw in finding the runtime of mergesort in the previous chapter. This is beyond the scope of this course.</li>
</ol>
</li>
<li>Big-Omega<ol>
<li>“greater than or equal”</li>
<li>作用<ol>
<li>prove Big-Theta: 夹逼证两端</li>
<li>It’s used to prove the difficulty of a problem. For example, ANY duplicate-finding algorithm must be Ω(N), because the algorithm must at least look at each element.</li>
</ol>
</li>
</ol>
</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Big_Three.png" alt="Big-Three"></li>
<li>Amortization!!! <img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Amortization.jpg" alt="摊销的势能证明"></li>
</ol>
<h3 id="4-5-Disjoint-Sets-不相交集"><a href="#4-5-Disjoint-Sets-不相交集" class="headerlink" title="4. 5 Disjoint Sets(不相交集)"></a>4. 5 Disjoint Sets(不相交集)</h3><ol>
<li><p><em><strong>Introduction</strong></em></p>
<ol>
<li><p>the Disjoint Set Interface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Interface DisjointSet &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种比较</p>
<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_Compare.png" alt="pic"></li>
</ol>
</li>
</ol>
</li>
<li><p><em><strong>Quick Find</strong></em></p>
<ol>
<li><p>Quick Find:使用整形数组下标作为对应的值，对应下标的值是分组编号</p>
</li>
<li><p>connect O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">   <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">          id[i] = qid;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><em><strong>Quick Union</strong></em></p>
<ol>
<li><p>仍然是整形数组下标作为对应的值如1，2，3；_arr[index]则是对应的parent父索引（使用index即值），形成树的结构；-1表示一个集合的根</p>
</li>
<li><p>implement</p>
<ol>
<li><p>connect-&gt;一个的根认另一个为根</p>
</li>
<li><p>isConnected-&gt;是否具有相同根，即到-1时的index是否为同一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">          parent[i] = i; <span class="comment">// 初始时都是分开的</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          p = parent[p]; <span class="comment">// 直接找到根部，直到值&lt;0则ok</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">      <span class="type">int</span> j= find(q);</span><br><span class="line">      parent[i] = j;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Tips</p>
<ol>
<li>潜在问题：树变得很长-&gt;通过高度&#x2F;weight解决（见4）</li>
<li>从运行时图表来看，QuickUnion 似乎比 QuickFind 差！但请注意 O(N) 作为上限。当我们的树平衡时， connect和isConnected都表现得相当好</li>
</ol>
</li>
</ol>
</li>
<li><p><em><strong>Weighted Quick Union(WQU) – LAB6 will implement</strong></em></p>
<ol>
<li>New rule: whenever we call connect, we always link the root of the smaller tree to the larger tree.新规则：每当我们调用connect时，我们总是将较小树的根链接到较大树。</li>
<li>smaller<ol>
<li>weight is smaller, weight means the number of items, proved better -&gt; rule: smallest weight to the largest weight</li>
<li>height is smaller</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/WeightedQU.png" alt="Pic"></li>
</ol>
</li>
<li>with weighted -&gt; O(logn) for connect and isConnected<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/WeightQU_example.png" alt="exmaple"></li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Prove_WQU.jpg" alt="simple proof"></li>
</ol>
</li>
<li>Why not heighted? -&gt; 您可能想知道为什么我们不根据高度而不是重量来链接树木。事实证明，这实现起来更复杂，并且给了我们相同的 θ(log N) 高度限制(实现复杂，性能不改)</li>
</ol>
</li>
<li><p><em><strong>Weighted Quick Union with Path Compression</strong></em></p>
<ol>
<li>问题与思路：每当我们调用find(x)时，我们都必须遍历从x到 root 的路径。因此，在此过程中，我们可以将我们访问的所有项目连接到它们的根，而无需额外的渐近成本</li>
<li>Amortized:通过扩展，从长远来看， connect和isConnected的平均运行时间几乎变得恒定O(1)！这称为摊销运行时间</li>
<li>Extension:<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_compareE.png" alt="extension"><ol>
<li>不是算法分析无需解决这个问题，只需要直到是O(1)即可</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="5-Trees-and-Hashing"><a href="#5-Trees-and-Hashing" class="headerlink" title="5. Trees and Hashing"></a>5. Trees and Hashing</h2><h3 id="5-1-Binary-Search-Tree-二叉搜索树"><a href="#5-1-Binary-Search-Tree-二叉搜索树" class="headerlink" title="5. 1 Binary Search Tree(二叉搜索树)"></a>5. 1 Binary Search Tree(二叉搜索树)</h3><ol>
<li><p>是TreeSet和TreeMap的底层实现，BST和在BST基础上实现的结构都不能有重复duplicate</p>
</li>
<li><p>List</p>
<ol>
<li>Skip List(not in cs61b), expected O(logn)</li>
<li>BST, expected O(logn)</li>
</ol>
</li>
<li><p>树的定义都知道，那记一记BST的特性</p>
<ol>
<li>二叉</li>
<li>大小限定–&gt;可以将三角形投影成线来可视化大小在数轴上</li>
</ol>
</li>
<li><p>搜索操作 O(logn)</p>
<ol>
<li><p>此处为裸实现，再次实现需要包装，使用递归(不要进行arms length base cases)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (T == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (sk.equals(T.key))</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (sk ≺ T.key)</span><br><span class="line">      <span class="keyword">return</span> find(T.left, sk);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>插入操作 O(logn)</p>
<ol>
<li><p>注意：总是在叶节点进行插入，一直找知道找到叶子</p>
</li>
<li><p>以下的BST是树与根节点的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key ik)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">   &#125; <span class="comment">// 叶节点的递归情况</span></span><br><span class="line">   <span class="keyword">if</span> (ik &lt; T.key) &#123;</span><br><span class="line">      T.left = insert(T.left,ik);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ik &gt; T.key) &#123;</span><br><span class="line">      T.right = insert(T.right,ik);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">   <span class="comment">// 树中的递归情况，包括找到相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>删除 O(logn), 有三种情况</p>
<ol>
<li>没有孩子-&gt;直接删</li>
<li>有一个孩子-&gt;父节点指针指向子节点， 使得本来没有被指向了，直接被垃圾回收</li>
<li>有两个孩子-&gt;选新新节点来代替 Hibbard删除<ol>
<li>新节点必须：比左子树中的所有内容都 &gt; 或者是&lt;比一切右子树</li>
<li>简单：左再最大(presuccessor)，或者右再最小(successor)</li>
</ol>
</li>
</ol>
</li>
<li><p>可以作为集合与映射(同时加上值即可)</p>
</li>
</ol>
<h3 id="5-2-B-Tree-Maybe-Boeing-Tree"><a href="#5-2-B-Tree-Maybe-Boeing-Tree" class="headerlink" title="5. 2 B-Tree (Maybe Boeing Tree)"></a>5. 2 B-Tree (Maybe Boeing Tree)</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization</a></li>
<li>描述性能<ol>
<li>深度depth: 连接数量</li>
<li>高度height: 树的最低深度，树的高度决定了最坏情况下的运行时间</li>
<li>平均深度average depth: 就像求均值一样，平均深度决定平均情况运行时间</li>
</ol>
</li>
<li>BST问题与改进<ol>
<li>BST最坏的插入顺序下会是theta(n)，变成一个链表，这很不好，方法–B-Tree</li>
<li>什么是最坏情况<ol>
<li>经过27页的论文证明，真正随机地插入数据，它实际上会变得相对茂密—-平均深度和高度预计为theta(logn)</li>
<li>但是我们并不总是能够以随机顺序插入 BST，不如按照时间进行排列</li>
</ol>
</li>
<li><em><strong>何谓BST平衡Banlanced</strong></em><ol>
<li>左右两半一样</li>
<li>每加一层&#x3D;&#x3D;加上面全部&#x3D;&#x3D;数量翻倍</li>
</ol>
</li>
</ol>
</li>
<li>B-Tree<ol>
<li>从一个crazy idea开始: 不要添加叶节点！当我们插入时，我们只添加到当前的叶节点，增加宽度<ol>
<li>Problem1: 还是O(N)，数量一多就麻烦了</li>
<li>Solution1: 对单个节点中的元素数量设置限制，L &#x3D; constant value使得O(1)，此处的思维涉及数据结构的本质(0. 8)</li>
<li>Problem2: 超出了如何解决</li>
<li>Solution2: 无论是根&#x2F;叶&#x2F;树种，我们将把该节点分成两半。通过向上移动中间左侧的节点，并将被拆分节点左侧的值连接到父节点上<ol>
<li>如果是中间节点，上移时要分配下游节点</li>
</ol>
</li>
</ol>
</li>
<li>专有名词<ol>
<li>2-3 Tree: L &#x3D; 2</li>
<li>2-4 或者 2-3-4 Tree: L &#x3D; 3</li>
<li>变形过程: split</li>
</ol>
</li>
<li>Insert和Delete详见<ol>
<li><a target="_blank" rel="noopener" href="https://joshhug.gitbooks.io/hug61b/content/chap11/chap112.html">gitbook</a>中的slide</li>
<li><a target="_blank" rel="noopener" href="https://joshhug.gitbooks.io/hug61b/content/chap11/chap113.html">deletion slide</a></li>
</ol>
</li>
<li><strong>Invariant不变量</strong>–导致树时浓密的<ol>
<li>所有叶子与源的距离必须相同</li>
<li>一个非叶节点k必须完全k+1个孩子</li>
</ol>
</li>
<li><strong>RunTime Effiency</strong><ol>
<li><del>log下标L+1 (N) 最佳(每个节点都是L-1满了时)和</del>log下标L (N) 最差</li>
<li>所得的树具有完美的平衡。操作的运行时间是 O(logN)</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/RunTime_B_Tree.png" alt="runtime"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-3-Black-Red-Tree-红黑树"><a href="#5-3-Black-Red-Tree-红黑树" class="headerlink" title="5. 3 Black-Red-Tree (红黑树)"></a>5. 3 Black-Red-Tree (红黑树)</h3><ol>
<li>Why? Ans:B-Tree implementation too painful and unclearly<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Why_BRT.png" alt="B-Tree implementation too painful and unclearly"></li>
</ol>
</li>
<li>rotate<ol>
<li>不能右:向右要有左</li>
<li>思路:数轴映射大小去理解</li>
<li>没有算法可以直接算出要怎么得出所有路径，但是可以在一定步数内达到</li>
</ol>
</li>
<li>LLRB-BST<ol>
<li>判断是否可行：两个Invariant</li>
<li>通过2-3Tree判断高度：red+black，&lt;2* height of the 2-3 tree</li>
</ol>
</li>
</ol>
<h3 id="5-4-Hashing"><a href="#5-4-Hashing" class="headerlink" title="5. 4 Hashing"></a>5. 4 Hashing</h3><ol>
<li>way to construct set and map<ol>
<li>Linked Structure: Skip Link</li>
<li>Self-Balance Structure: llrb, b-tree</li>
<li>random: hashing<ol>
<li>相比于树在set和map的优势 – 不用每个item都可以比较</li>
<li>In Java, implemented as java.util.HashMap and java.util.HashSet.</li>
</ol>
</li>
</ol>
</li>
<li>Introduction to Hash<ol>
<li>使用数据作为索引<ol>
<li>Problem1: how to deal with diffierent data to avoid collision?</li>
<li>Solution1: 如对于小写字母(26)个，”cat”&#x3D;&#x3D;3*27^2+3*27^1+2*27^0，可以使得26个组合错开，从而推广到其他如ascii</li>
</ol>
</li>
</ol>
</li>
<li>Dive into hashing<ol>
<li>Problem1: Integer Overflow(整数溢出了)<ol>
<li>Ans: 选取不太大的base如31</li>
</ol>
</li>
<li>HashCode:a hash code “projects a value from a set with many (or even an <strong>infinite number</strong> of) members to a value from a set with a <strong>fixed number</strong> of (fewer) members.” – 缩小空间</li>
<li>Problem2: How do we <strong>resolve hashCode collisions</strong>?<ol>
<li>use bucket is one way</li>
</ol>
</li>
<li>Problem3: How do we <strong>compute a hash code</strong> for arbitrary objects?<ol>
<li>Ans: in java, we use hashCode() for every objects，default hashCode()返回的是对象的地址</li>
</ol>
</li>
<li>Proble4: what if the <strong>hashCode is negative</strong>?<ol>
<li>Ans: Math.floorMod(x,y)可以取余负数</li>
</ol>
</li>
<li>HashTable(哈希表): 哈希表 “是一种存储信息的方式，其中有 M 个存储桶，分别存储 N 个项目。每个项目都有一个 “hashCode”，告诉你该把它放在 M 个桶中的哪个桶里</li>
<li>桶也会O(N)怎么办？– Load Factor<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_LoadFactor.png" alt="Load Factor for runtime"></li>
<li>条件和运行时间<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_Condition.png" alt="条件和运行时间"></li>
</ol>
</li>
<li>Java中的hashing注意点<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Hashing_Java.png" alt="Java中的hashing注意点"><ol>
<li><p>演示的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive data structure</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.hashCode() + <span class="number">31</span> * <span class="built_in">this</span>.left.hashCode() + <span class="number">31</span> * <span class="number">31</span> * <span class="built_in">this</span>.right.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collection</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (Object o: <span class="built_in">this</span>) &#123;</span><br><span class="line">      hashCode = hashCode * <span class="number">31</span>;</span><br><span class="line">      hashCode += o.hashCode();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>A typical hash code base is a small prime.</p>
<ol>
<li>Why prime?o Never even:Avoids the overfow issue on previous slide.Lower chance of resulting hashCode having a bad relationship with theOnumber of buckets: See study guide problems and hw3.</li>
<li>Why small?o Lower cost to compute.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>More Details in dir &#x2F;CS106B&#x2F;Summary.md</li>
</ol>
<h3 id="5-5-Heaps-and-PQs"><a href="#5-5-Heaps-and-PQs" class="headerlink" title="5. 5 Heaps and PQs"></a>5. 5 Heaps and PQs</h3><ol>
<li><p>Problem: how to use Theta(M) space to filter the Theta(N) Information? – N &gt;&gt; M</p>
<ol>
<li>case: 流量监视</li>
</ol>
</li>
<li><p>ADTs: Priority Queue（优先队列）</p>
<ol>
<li>可以通过传入的比较器来决定是MinPQ还是MaxPQ</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item <span class="keyword">extends</span> <span class="title class_">Comparator</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">   <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">   <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">   <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">   <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ADTs: Heap(堆)</p>
<ol>
<li>Heap Properties<ol>
<li>Complete: 从左到右，紧密填满一层</li>
<li>Size: the parent is the max&#x2F;min of the tree (max-heap&#x2F;min-heap)</li>
</ol>
</li>
<li>Operations(cs106很熟悉了)<ol>
<li>add(Item x): 从底部添加，再与parent比较，可以的话交换</li>
<li>removeSmallest(): 最后一个item与顶端交换，再比较交换</li>
<li><a target="_blank" rel="noopener" href="https://goo.gl/wBKdFQ">reference showcase</a></li>
<li>Runtime<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Heap_Operation.png" alt="Runtime"></li>
</ol>
</li>
</ol>
</li>
<li><p>Data Structure: Tree Representation in Java – can be used to implement Heap</p>
<ol>
<li><p><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/TR_4.png" alt="四种"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slibing presentation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">   Key k; <span class="comment">// e.g. 0</span></span><br><span class="line">   Tree1C favoredChild;</span><br><span class="line">   Tree1C sibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean array</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">   Key[] keys;</span><br><span class="line">   <span class="type">int</span>[] parents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最适合heap的<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/TR_ArraySentinel.png" alt="Array"></p>
<ol>
<li>0不要<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapArray1.png" alt="0不要"></li>
<li>0要<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapArray2.png" alt="0要"></li>
<li>对于数组*2的解释(0不要的)<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/HeapIndex.jpg" alt="HeapIndex"></li>
<li>如果是0也一样的思路<strong>找一下规律再推广</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-6-Data-Structure-Summary"><a href="#5-6-Data-Structure-Summary" class="headerlink" title="5. 6 Data Structure Summary"></a>5. 6 Data Structure Summary</h3><ol>
<li>可重复的Sets和Maps没有涉及到</li>
<li>数据结构是关于数据的存储和搜索的</li>
<li>DataStructure Now Learned<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/DataStructSummary.png" alt="DataStructure Now Learned"></li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/DataStructSum2.png" alt="DataStructure Now Learned2"></li>
</ol>
</li>
</ol>
<h3 id="5-7-Compression-Originally-38"><a href="#5-7-Compression-Originally-38" class="headerlink" title="5. 7 Compression(Originally 38)"></a>5. 7 Compression(Originally 38)</h3><ol>
<li><p>压缩的核心</p>
<ol>
<li>使用不多于8位来表示，which codewords go with which symbols</li>
<li>Sequences with no existing redundancy or order may actually get enlarged – 可能会更大</li>
</ol>
</li>
<li><p>前缀码</p>
<ol>
<li>Problem1: 一连串的字符通过不加停止(无标志)，如何避免歧义 – Avoid ambiguity by making code prefix free<ol>
<li>Solution1: 可以使用01树来表示前缀码!!!</li>
</ol>
</li>
<li>Problem2: 不同文本的最佳前缀码是不同的<ol>
<li>Solution2: Huffman Coding<ol>
<li>Flow<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_Huffman.png" alt="flow"><ol>
<li><strong>make sure best</strong>：构建过程中”动态地”匹配出综合起来频率最低的进行加叶子，并会将频率进行叠加</li>
</ol>
</li>
<li>Huffman Coding Tree Property<ol>
<li>使用binary tree</li>
<li>由于前缀码的限制，只有叶子可以作为选择的内容</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Huffman Coding Data Structure</p>
<ol>
<li>For encoding (bitstream to compressed bitstream) – array&#x2F;hashmap&lt;char,Bitsequence&gt;</li>
<li>For decoding: longest matching prefix – Tries ok</li>
</ol>
</li>
<li><p>现实世界中的huffman</p>
<ol>
<li><p>实现一(少): Build one corpus per input type. – result in suboptimal(次佳) encoding.</p>
</li>
<li><p>实现二(实际使用的方式): For every possible input file, create a unique code just for that file. Send the code along with the compressed file.</p>
<ol>
<li>安全性问题</li>
<li>独立存储编码表</li>
</ol>
</li>
<li><p>Work Flow</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// encoding</span></span><br><span class="line">Step <span class="number">1</span>: Count frequencies.</span><br><span class="line">Step <span class="number">2</span>: Build encoding array and decoding trie.</span><br><span class="line">Step <span class="number">3</span>: Write decoding trie to output.huf.</span><br><span class="line">Step <span class="number">4</span>: Write codeword <span class="keyword">for</span> each symbol to output.huf.</span><br><span class="line"></span><br><span class="line"><span class="comment">// decoding</span></span><br><span class="line">Step <span class="number">1</span>: Read in decoding trie.</span><br><span class="line">Step <span class="number">2</span>: Use codeword bits to walk down the trie, outputting symbols every time you reach a leaf. </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>其他压缩方式</p>
<ol>
<li>Run-length encoding: XXXXXXXXXYYYYXXXXX -&gt; X10Y4X5</li>
<li>LZW sytle compression</li>
<li>Lossy Compression</li>
</ol>
</li>
<li><p>Compression Model</p>
<ol>
<li>数学界限: 无法<strong>利用一个通用算法</strong>将一个文件压缩到50%，但是不通用可以达到这个效率<ol>
<li>反证一：可以递推至1个字节，显然无法辨别不同信息</li>
<li>反证二(鸽巢原理)：现有2^1000(1000字节)个可能，压缩为一半后最多有1+2+4+…+2^500  &#x3D; 2^501 - 1个可能性，无法容纳 – 长度也可以是信息</li>
</ol>
</li>
<li>为避免使用机器特殊的压缩算法比如if1则咋咋咋if0则咋咋咋，将算法源代码本身的位数包括在内</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_2Models.png" alt="Two Model&#39;s"></li>
<li>model two compression example<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Compression_Model2example.png" alt="model2"></li>
</ol>
</li>
</ol>
</li>
<li><p>LZW details(Extra)</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1U8XO6CWfcU4QgrFOZmGjAgmaKxLc8HXk6qB1JQVlqrg/">showcase</a></p>
</li>
<li><p>特点：使用新添加的codeword(ascii中没有)来表示symbols，但是在压缩和解压缩时无需传递新的表</p>
<ol>
<li>宏观：添加键是由规律可逆的，可以通过序列直接得出</li>
<li>细节(建议看完Encoding再回来)<ol>
<li>新添加的码也是一个一个进行添加的，但是只需要根据之前的码来，后依赖前，前不依赖后</li>
<li>每一次使用的键都是以前由出现过前缀才添加的，并且一开始只能由ascii码开始</li>
<li>综上decoding时也按照规律即可</li>
</ol>
</li>
</ol>
</li>
<li><p>Encoding</p>
<ol>
<li>Codewords for Multiple Symbols(一码对于多个char)</li>
<li>每一次添加Codeword都是为后续做准备，对于有多重复的内容具有较高的压缩能力</li>
<li><em><strong>新添加的Codeword</strong></em>: 当前最长前缀是否有codeword可以表示 -&gt; 没有: 添加当前最长前缀；有: 使用codeword表示，并添加新的最长前缀<ol>
<li>注意一点是前缀是慢慢累积上来的，要一个一个添加，不能一次性加很多个</li>
</ol>
</li>
</ol>
</li>
<li><p>Decoding – 没搞懂，有时间再看ppt</p>
<ol>
<li>flow<ol>
<li>也符合当前最长前缀和累计前缀的两个不变量</li>
<li>新表示一定可以找到对应的编码，可以通过归纳法来思考(但这并不是证明，会有特殊情况)<ol>
<li>简略：压缩时需要根据前缀进行匹配(一开始肯定不会有新编码)，而解压时会从当前已知前缀中找到对应编码</li>
<li>较详细：压缩时是通过当前最长匹配没有时添加已有的旧编码并添加新的编码(往自己+后看)，而解压缩时是直接找到对应编码后再添加新的编码(往自己+前看) – 二者在时序上还是有一点差别，有Special Case</li>
</ol>
</li>
</ol>
</li>
<li>Spacial Case – 会出现没有编码可用，but可以推断<ol>
<li>Why?<ol>
<li>looked ahead(向尾端看) one character to created new codewords.  When decompressing we look BACK to create new codewords</li>
<li><em><strong>Key Reason: 编码时往前看会预先得到下一个codeword，会有连续使用新编码的情况，depression时如果连续使用新编码的话只是添加先前的codeword，无法添加最新的codeword，但是可以推断</strong></em></li>
</ol>
</li>
<li>解决方法：设为未知数，假定已知来进行添加新编码(前一个+后一个第一个(其实就是前一个第一个))，改新编码就是对应位的编码</li>
</ol>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Start with ‘trivial’ codeword table </span><br><span class="line">where each codeword corresponds to one ASCII symbol.</span><br><span class="line"><span class="number">2.</span> When codeword X is encountered, </span><br><span class="line"><span class="keyword">return</span> appropriate symbols <span class="title function_">S</span><span class="params">(X)</span> given in codeword table.</span><br><span class="line"><span class="number">3.</span> Given consecutive codewords X1 and X2add codeword</span><br><span class="line">corresponding to [S(X1) + firstCharacterOf(S(X2))]</span><br><span class="line"><span class="comment">// 第三步是可以实时记录当前各个最长前缀吗</span></span><br><span class="line"><span class="comment">// firstChar是为了保持顺序而不跳步</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Lossy Compression details(Extra)</p>
<ol>
<li>原ppt上的内容很少 – See EE20 (or perhaps 16A&#x2F;16B?) for more</li>
</ol>
</li>
</ol>
<h3 id="5-8-Compression-Complexity-and-P-NP"><a href="#5-8-Compression-Complexity-and-P-NP" class="headerlink" title="5. 8 Compression, Complexity, and P&#x3D;NP?"></a>5. 8 Compression, Complexity, and P&#x3D;NP?</h3><ol>
<li><p>柯尔莫戈洛夫复杂性 – Kolmogorov Complexity</p>
<ol>
<li>Definition: 是一种度量，它定义为生成一个特定对象（如比特流）的最短可能程序的长度(also: Kolmogorov复杂度是指生成某个字符串所需的最短计算机程序的长度)</li>
<li>Fact1: 这个定义与程序编写所用的具体编程语言无关。无论是Java、Python、C++还是其他任何语言，最短程序的长度在不同语言之间最多相差一个常数因子<ol>
<li>a completely random sequence of 1,000,000 bits has at best, a 1 in 2499999 chance of being compressed by 50%.</li>
</ol>
</li>
<li>Fact2: 不可能编写一个程序来计算任何比特流的柯尔莫哥洛夫复杂度<ol>
<li>推论：if we can’t even compute the length of the shortest program, it is also impossible to write the “perfect” compression algorithm – Optimal compression algorithm that works for all inputs does not exist! Leads to a logical fallacy</li>
</ol>
</li>
<li>Fact3: 理论上我们无法创建一种最佳压缩算法，将目标比特流 B 作为输入，并输出能输出该比特流的最短Java程序</li>
</ol>
</li>
<li><p>我们能创造一种有空间&#x2F;时间限制的压缩算法吗？可以！</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>P和NP(莫名高大上的东西) – 本质：计算复杂性理论中的两个重要问题类别</p>
<ol>
<li><p>P（多项式时间）</p>
<ol>
<li>高大上说法：类P包含所有可以在多项式时间内由确定性图灵机解决的<em><strong>决策问题</strong></em>（即答案是“是”或“否”的问题）。</li>
<li>平民说法：这意味着存在一个算法能够解决这个问题，并且其运行时间被输入大小的多项式函数所限制</li>
</ol>
</li>
<li><p>NP（非确定性多项式时间）</p>
<ol>
<li>高大上说法：类 NP 包含所有解答可以在多项式时间内由确定性图灵机验证的决策问题。或者说，NP 类问题可以在多项式时间内由非确定性图灵机解决</li>
<li>平民说法：在 NPNP 类问题中，如果给定一个“证书”或“见证”（一个假定的解答），可以在多项式时间内验证其正确性</li>
</ol>
</li>
<li><p>P &#x3D; NP? – 可验证 &#x3D;&#x3D; 可解答</p>
<blockquote>
<p>One reason to think yes:<br>Easy to check any given answer.<br>Maybe with the right pruning rules you can zero in on the answer?</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="6-Graphs"><a href="#6-Graphs" class="headerlink" title="6. Graphs"></a>6. Graphs</h2><h3 id="6-1-Tree-and-Graph-Traversals"><a href="#6-1-Tree-and-Graph-Traversals" class="headerlink" title="6. 1 Tree and Graph Traversals"></a>6. 1 Tree and Graph Traversals</h3><ol>
<li>树的遍历<ol>
<li><p>多种方式<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Traversal_ways.png" alt="multiple ways"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. preOrder d b a c e f g</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">preOrder</span><span class="params">(BSTNode x)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   print(x.value);</span><br><span class="line">   preOrder(x.left);</span><br><span class="line">   preOrder(x.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. inOrder a b c d e f g</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">inOrder</span><span class="params">(BSTNode x)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inOrder(x.left);</span><br><span class="line">   print(x.value);</span><br><span class="line">   inOrder(x.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. postOrder a c b e g f d</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">postOrder</span><span class="params">(BSTNode x)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   postOrder(x.left);</span><br><span class="line">   postOrder(x.right);</span><br><span class="line">   print(x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. level order 层次遍历bfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val=<span class="number">0</span>,left=<span class="literal">None</span>,right=<span class="literal">None</span></span>):</span><br><span class="line">      <span class="variable language_">self</span>.val = val</span><br><span class="line">      <span class="variable language_">self</span>.left = left</span><br><span class="line">      <span class="variable language_">self</span>.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">root</span>):</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">   </span><br><span class="line">   res = []</span><br><span class="line">   queue = [root] <span class="comment"># bfs 常常使用 queue</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> queue:</span><br><span class="line">      current_level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">      current_level_nodes = []</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(current_level_size):</span><br><span class="line">         node = queue.pop(<span class="number">0</span>)</span><br><span class="line">         current_level_nodes.append(node.val)</span><br><span class="line"></span><br><span class="line">         <span class="comment"># 左右节点进queue</span></span><br><span class="line">         <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">         <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">      </span><br><span class="line">      res.append(current_level_nodes)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>各自有用处</p>
<ol>
<li>Postorder Traversal for gathering file sizes.</li>
<li>前序遍历可以列出文件系统信息<code>ls</code></li>
</ol>
</li>
</ol>
</li>
<li>Simple Graph<ol>
<li><p>条件</p>
<ol>
<li>没有环loops</li>
<li>没有平行边parallel edges</li>
</ol>
</li>
<li><p>接下来都是默认的simple Graph</p>
</li>
<li><p>s-t Connectivity Problem – DFS</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1lTo8LZUGi3XQ1VlOmBUF9KkJTW_JWsw_DOPq8VBiI3A/edit#slide=id.g76e572688_0_185">reference showcase in google</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">Mark s</span><br><span class="line"><span class="title function_">if</span> <span class="params">(s == t)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   any unmarked neighbor v of <span class="title function_">s</span> <span class="params">(<span class="keyword">for</span>?)</span>, </span><br><span class="line">   <span class="keyword">if</span> (connected(v, t)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Graph Traversal</p>
<ol>
<li><p>DFS preOrder: Action is before DFS calls to neighbors</p>
</li>
<li><p>DFS Postorder: Action is after DFS calls to neighbors.</p>
</li>
<li><p>BFS order (like tree level order)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs postOrder</span></span><br><span class="line">mark(s)</span><br><span class="line">For each unmarked neighbor n of s, dfs(n)</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs preOrder</span></span><br><span class="line">mark(s)</span><br><span class="line">print(s)</span><br><span class="line">For each unmarked neighbor n of s, dfs(n)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="6-2-Graph-Traversals-and-Implementations-BFS-and-DFS"><a href="#6-2-Graph-Traversals-and-Implementations-BFS-and-DFS" class="headerlink" title="6. 2 Graph Traversals and Implementations(BFS and DFS)"></a>6. 2 Graph Traversals and Implementations(BFS and DFS)</h3><ol>
<li><p>Shortest Path implemented with bfs</p>
<ol>
<li>not yet for weighted, 只适用于边长为1的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">remove vertex v from fringe</span><br><span class="line">foreach unmarked neighbor n of v</span><br><span class="line">   mark n, add n to fringe</span><br><span class="line">   set edgeTo[n] = v, set distTo[n] = distTo[v] + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Graph API</p>
<ol>
<li>To Implement our graph algorithms, we need<ol>
<li>API</li>
<li>data structure</li>
</ol>
</li>
<li>Graph API Decision: 普灵斯顿版<ol>
<li><p>Common convention(惯例): 需要将节点进行适用int进行阐述，使用Map&lt;Label, Integer&gt;</p>
</li>
<li><p>Graph API from our optional textbook</p>
<ol>
<li>limitations<ol>
<li>Number of vertices must be specified in advance, Map&lt;Label, Integer&gt;</li>
<li>not weighted</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>; <span class="comment">// Create empty graph with v vertices</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>;</span><br><span class="line">   Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>; <span class="comment">// vertices adjacent to v</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>; <span class="comment">// number of V / E</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">degree</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">degree</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> w: G.adj(v)) &#123;</span><br><span class="line">         degree += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> degree;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; G.V(); v += <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> w: G.adj(v)) &#123;</span><br><span class="line">            System.out.print(v);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            System.out.print(w);</span><br><span class="line">            <span class="comment">// 会有重复反向的出现</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Graph Representation and Graph Algorithm Runtime</p>
<ol>
<li>Representation表示<ol>
<li>Adjacency Matrix：无向图是对称矩阵<ol>
<li>G.adj(v)返回iterator可以使用next(), Theta(v) to iterate all neighbors, using hasNext() and next() – better than before theta(v^2)</li>
</ol>
</li>
<li>Edge Sets: 边的集合HashSet&lt;Edge&gt;</li>
<li>Adjacency list: Maintain array of lists indexed by vertex number – 数组+链表 <strong>最受欢迎的</strong><ol>
<li>完全图&#x2F;密度很高时print()时Worst为O(V^2)，密度比较小时是Theta(V)–2*V也是</li>
<li>all cases: Theta(V+E): Create V iterator, print E times per iterator</li>
<li>all cases和上述分类可以互相转换</li>
</ol>
</li>
<li>Runtime<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_Runtime.png" alt="Runtime"></li>
</ol>
</li>
</ol>
</li>
<li><p>Implementation</p>
<ol>
<li><p>bare-bones undirected graph implementation – Using Adjacency List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;  <span class="keyword">private</span> List&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.V = V;</span><br><span class="line">      adj = (List&lt;Integer&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>[V];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">         adj[v] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">      adj[v].add(w);</span><br><span class="line">      adj[w].add(v);</span><br><span class="line">      <span class="comment">// double size</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> adj[v]; <span class="comment">// return a list</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的设计模式：Decouple(解耦) type from processing algorithm</p>
<ol>
<li><p>三步走</p>
<ol>
<li>Create a graph object.</li>
<li>Pass the graph to a graph-processing method (or constructor) in a client class.</li>
<li>Query the client class for information.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for example: dfsPaths</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DfsPaths</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] edgeTo; <span class="comment">// &quot;adjcency list&quot; in the path</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> s; <span class="comment">// 从 s 开始遍历</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DfsPaths</span><span class="params">(Graph G, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">      <span class="comment">// initializing ...</span></span><br><span class="line">      dfs(G,s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="comment">// vertex visits (no more than V calls) -- O(v)</span></span><br><span class="line">      marked[v] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> w: G.adj(v)) &#123;</span><br><span class="line">         <span class="comment">// edge considerations, each constant time</span></span><br><span class="line">         <span class="comment">// no more than 2E calls -- O(E)</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">            edgeTo[w] = v; <span class="comment">// v可到的w</span></span><br><span class="line">            dfs(G,w); <span class="comment">// 进行遍历w邻居</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPathTo(v))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 直接返回没有</span></span><br><span class="line">      List&lt;Integer&gt; Path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">         <span class="comment">// 从目标开始往前找</span></span><br><span class="line">         path.add(x);</span><br><span class="line">      &#125;</span><br><span class="line">      path.add(s);</span><br><span class="line">      Collections.reverse(path);</span><br><span class="line">      <span class="comment">// 由于从目标开始往前找，所以要进行reverse</span></span><br><span class="line">      <span class="keyword">return</span> path;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> markde[v];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Graph G, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">      Queue&lt;Integer&gt; fringe = </span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br><span class="line">      fringe.enqueue(s);</span><br><span class="line">      marked[s] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (!fringe.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> fringe.dequeue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj(v)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">            fringe.enqueue(w);</span><br><span class="line">            marked[w] = <span class="literal">true</span>;</span><br><span class="line">            edgeTo[w] = v;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DFS cost 3 Models</p>
<ol>
<li>O(v): 不适用于多边图</li>
<li>O(E): 不适用于多点图</li>
<li>O(V+E): ok – 我们从未正式定义过多变量渐近学，而且结果证明它的定义有些不准确(not tight bound)</li>
<li>上述的实现dfs<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dfs.png" alt="上述的实现"></li>
</ol>
</li>
<li><p>BFS cost models</p>
<ol>
<li>bfs理论上时间复杂度和dfs相同，不同是bfs总是能找到最短的路径</li>
<li>上述的bfs<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_bfs.png" alt="bfs"></li>
</ol>
</li>
<li><p>using adjecncy matrix<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_adjMatrix.png" alt="using adjecncy matrix"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>关于DFS</p>
<ol>
<li>ANY recursive algorithm can be implemented using iteration and a stack – 将bfs的queue变成stack</li>
</ol>
</li>
</ol>
<h3 id="6-3-Shortest-Paths"><a href="#6-3-Shortest-Paths" class="headerlink" title="6. 3 Shortest Paths"></a>6. 3 Shortest Paths</h3><ol>
<li>DFS or BFS?<ol>
<li>二者均可以遍历图，bfs可以在图中找到最小的路径，但是仅限于unweighted，每条边默认为1的情况<ol>
<li>BFS is worse for absurdly “bushy” graphs.</li>
<li>DFS is worse for spindly graphs.</li>
</ol>
</li>
</ol>
</li>
<li>最小路径树(SPT not MST): 详见dijkstra – Can find the SPT using Dijkstra’s algorithm.</li>
<li>Dijkstra(以下都是对于无负权重且联通图，可以是有环图)<ol>
<li>前期试探的不变量<ol>
<li>Invariant 1：找到抵达某个顶点(t)的最短路径–solution是没有环的(如果有环可以减掉)</li>
<li>Invariant 2: 每条到某个顶点的最短路都包含了到达涵盖其他点的最短路 – 从全局观点反证，如果不是，选最短会更短；同理，每条最短路都是在前一条最短路上加上当前的最短路</li>
<li>Invariant 3: 在一个连通图中，从某一个点到达其他所有顶点的最短路径是一颗树(Shortest Paths Tree:SPT)，而且总是有V-1个节点 – 有且只能由一条到达(可以是相等的，否则一定有大有小)</li>
</ol>
</li>
<li>试探性(2，3不懂可以看ppt)<ol>
<li>by Hand：其实是默认的dfs，只不过我们可以随时换方向</li>
<li>单纯的dfs：不可行</li>
<li>dfs+relaxation：也可能导致错误答案，生成的SPT是错误的</li>
</ol>
</li>
<li>Dijkstra: best first search<ol>
<li><p>Persudocode, <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&loop=false&delayms=3000">showcase</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data form: &#123;[0:+infinity], [1,+infinity], ...&#125;</span></span><br><span class="line">Dijkstra:</span><br><span class="line">   PQ.add(source, <span class="number">0</span>)</span><br><span class="line">   For other vertices v, PQ.add(v, infinity)</span><br><span class="line">   While PQ is not empty:</span><br><span class="line">      P = PQ.removeSmallest() <span class="comment">// 一开始一定是source</span></span><br><span class="line">      Relax all edges from P</span><br><span class="line"></span><br><span class="line">Relaxing:</span><br><span class="line">   <span class="keyword">if</span> distTo[p] + w &lt; distTo[q]:</span><br><span class="line">      distTo[q] = distTo[p] + w</span><br><span class="line">      edgeTo[q] = p  <span class="comment">// set the front</span></span><br><span class="line">      PQ.updatePriority(q,distTo[q])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Invariants</p>
<ol>
<li>edgeTo[v] is the best known predecessor of v.(当前的)</li>
<li>distTo[v] is the best known total distance from source to v.(当前的)</li>
<li>PQ contains all unvisited vertices in order of distTo.(还没确定为最好的)</li>
<li>被移除(最开头)的肯定是最优选(回答了问题：为什么可以先移出来呢？) – 被移除的首先是当前最优，而由于没有负权重，以后要到达这个顶点一定是要更多条边，所以肯定最优的<ol>
<li><strong>解决的思路</strong>: 无法一下子从全局切入就回到这一步进行切入</li>
</ol>
</li>
<li>路径都可以通过edgeTo[destination]找到最开始的路径，因为会实时根据比较长度来确定某些节点的前一个节点(可以是两个节点的同一个节点)，最终会形成一条路径</li>
</ol>
</li>
<li><p>特点</p>
<ol>
<li>Always visits vertices in order of total distance from source.(按照)</li>
<li>Relaxation always fails on edges to visited (white) vertices. – Invariants 4中已经将清楚了</li>
<li>会平均地检测一切(遍历全部的边:贪心算法)，不像A*一样往一个方向进行试探性搜索</li>
<li>正确性证明<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dijkstraProof.png" alt="正确性证明"></li>
</ol>
</li>
<li><p>Runtime<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Graph_dijkstraRuntime.png" alt="Dijkstra’s Algorithm Runtime"></p>
</li>
</ol>
</li>
</ol>
</li>
<li>A*<ol>
<li>Simple idea: d(s,v) + h(v,destination)，其中h(..)是一个估计值 – A*算法的性能很大程度上取决于启发式函数h(x)的选择</li>
<li>A* Heuristic 根据经验&#x2F;其他信息进行运行，详细在CS188中(AI导论)</li>
</ol>
</li>
</ol>
<h3 id="6-4-Minimum-Spanning-Trees"><a href="#6-4-Minimum-Spanning-Trees" class="headerlink" title="6. 4 Minimum Spanning Trees"></a>6. 4 Minimum Spanning Trees</h3><ol>
<li>Determine whether a undirected graph contains cycles(是否有环)<ol>
<li>DFS: O(V+E) for worst, 需要经过所有点和边</li>
<li>WQU: 使用DisjointSet，对每条边检查是否已经connected，如果isConnected()，那么有环 – O(V + Eα(V))，如果有path compression的话</li>
</ol>
</li>
<li>Undirected Graph’s spanning tree(生成树)<ol>
<li>生成树: 连通、无环、所有点</li>
<li>最小生成树(MST): 权重和最小的生成树，最小生成树不唯一<ol>
<li>SPT和MST不一样，SPT取决于source node，MST是全局的没有source node – 关系: SPT 有时是 MST</li>
</ol>
</li>
</ol>
</li>
<li>连通无向MST<ol>
<li>Cut Property<ol>
<li>cut:切分是将图形节点分配到两个非空集合中(不用isConnected())，无共享节点</li>
<li>crossing edge:交叉边是将一个集合中的节点与另一个集合中的节点连接起来的边</li>
<li>切割属性：给定任何切割，最小权重交叉边都在 MST 中，proof below<ol>
<li>反证法，如果不是最小的交叉边，那换一下就变成更小了</li>
<li><strong>如何找到切割</strong>: 先假设不连通就好了(狗头)，先把边拿掉，也就是分成多个(两个)不同的部分</li>
</ol>
</li>
</ol>
</li>
<li>寻找MST<ol>
<li><p>Prim</p>
<ol>
<li><p>Runtime: assuming E &gt; V, we have O(E log V)</p>
<ol>
<li>Insertions: V, each costing O(log V) time</li>
<li>Delete-min: V, each costing O(log V) time.</li>
<li>DecreasePriority: E, each costing O(log V) time – 就是priorityQueue修改然后再重排</li>
</ol>
</li>
<li><p>代码示例</p>
<ol>
<li>如果edge一样随便选，MST有时并不唯一</li>
<li>Prim implementation code的特点是：只检查一条边一次，之前检查的先记录起来避免重复</li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1NFLbVeCuhhaZAM1z3s9zIYGGnhT4M4PWwAc-TLmCJjc/edit#slide=id.g32eeaa4a46_0_423">伪代码流程</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1GPizbySYMsUhnXSXKvbqV4UhPCvrt750MiqPPgU-eCY/edit#slide=id.g9a60b2f52_0_205">实现代码流程</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Persudocode</span></span><br><span class="line"><span class="number">5.</span> start from arbitrary start node</span><br><span class="line"><span class="number">6.</span> repeatedly add shortest edge that has one node </span><br><span class="line">   inside the MST under construction.</span><br><span class="line">   (会有重复，后续具体代码实现可以改进)</span><br><span class="line"><span class="number">7.</span> Repeat until V-<span class="number">1</span> edges.</span><br><span class="line">Correctness: Cut Property</span><br><span class="line"></span><br><span class="line"><span class="comment">// Realistic Implementation Demo</span></span><br><span class="line">   <span class="comment">// dijkstra-like 计算边长而不是总长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimMST</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">PrimMST</span><span class="params">(WeightedGraph G)</span> &#123;</span><br><span class="line">      edgeTo = <span class="keyword">new</span> <span class="title class_">Edge</span>[G.V()];</span><br><span class="line">      distTo = <span class="keyword">new</span> <span class="title class_">double</span>[G.V()];</span><br><span class="line">      marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">      fringe = <span class="keyword">new</span> <span class="title class_">SpecialPQ</span>&lt;Double&gt;(G.V()); </span><br><span class="line"></span><br><span class="line">      distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">      setDistancesToInfinityExceptS(s);</span><br><span class="line">      <span class="comment">// 选定source</span></span><br><span class="line">      insertAllVertices(fringe);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!fringe.empty()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> fringe.delMin();</span><br><span class="line">         <span class="comment">// 已经确定的MST node, 就是min crossing edge</span></span><br><span class="line">         scan(G, v);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(WeightedGraph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">         marked[v] = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">for</span> (Edge e: G.adj(v)) &#123;</span><br><span class="line">            <span class="comment">// 看看和最低点相邻的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (marked[w]) &#123; <span class="keyword">continue</span>; &#125; </span><br><span class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w]) &#123;</span><br><span class="line">               <span class="comment">// 随时更新，和dijkstra很像</span></span><br><span class="line">               distTo[w] = e.weight();</span><br><span class="line">               edgeTo[w] = e;</span><br><span class="line">               pq.decreasePriority(w, distTo[w]);</span><br><span class="line">               <span class="comment">// 重新排一下，只有最低才确定，否则只是更新</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Kruskal</p>
<ol>
<li><p>Runtime<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/MST_KruskalRuntime.png" alt="runtime"></p>
<ol>
<li>union和isConnected涉及路径压缩</li>
</ol>
</li>
<li><p>Code</p>
<ol>
<li>添加时会优先考虑最小边，形成环就丢弃，满足cut property</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persudocode</span></span><br><span class="line">Initially mark all edges gray.</span><br><span class="line">Consider edges in increasing order of weight.</span><br><span class="line">Add edge to <span class="title function_">MST</span> <span class="params">(mark black)</span> unless doing so creates a cycle.</span><br><span class="line">Repeat until V-<span class="number">1</span> edges.</span><br><span class="line"></span><br><span class="line"><span class="comment">// realistic implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Edge&gt; mst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Edge&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span> &#123;</span><br><span class="line">      MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> <span class="title class_">MinPQ</span>&lt;Edge&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Edge e : G.edges()) &#123;</span><br><span class="line">        pq.insert(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">WeightedQuickUnionPC</span> <span class="variable">uf</span> <span class="operator">=</span> </span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">WeightedQuickUnionPC</span>(G.V());</span><br><span class="line">      <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="type">Edge</span> <span class="variable">e</span> <span class="operator">=</span> pq.delMin();</span><br><span class="line">         <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> e.from();</span><br><span class="line">         <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.to();</span><br><span class="line">         <span class="keyword">if</span> (!uf.connected(v, w)) &#123;</span><br><span class="line">            <span class="comment">// 检查是否为环，使用到Disjoint Sets</span></span><br><span class="line">            uf.union(v, w);</span><br><span class="line">            mst.add(e); </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="6-5-Range-Searching-and-Multi-Dimensional-Data"><a href="#6-5-Range-Searching-and-Multi-Dimensional-Data" class="headerlink" title="6. 5 Range Searching and Multi-Dimensional Data"></a>6. 5 Range Searching and Multi-Dimensional Data</h3><ol>
<li>K-D Tree<ol>
<li>best side优先到完</li>
<li>bad side测量最短距离桶min比，如果没有比他大的就进行剪枝</li>
</ol>
</li>
<li>uniform partitioning<ol>
<li>没有subspace</li>
</ol>
</li>
</ol>
<h3 id="6-6-Prefix-Operations-and-Tries"><a href="#6-6-Prefix-Operations-and-Tries" class="headerlink" title="6. 6 Prefix Operations and Tries"></a>6. 6 Prefix Operations and Tries</h3><ol>
<li>Stringed Set&#x2F;Map的另一种实现: Tries(Retrieval Tree)<ol>
<li>对于String keys<ol>
<li>将string拆分成为一个一个的char</li>
<li>共同的点(node)可以被共享</li>
<li>是否包含增加判断</li>
</ol>
</li>
<li>problem1: 如何判断是不是一个词<ol>
<li>到末尾时判断为F</li>
<li>都不一样，没在树里</li>
</ol>
</li>
<li>Code<ol>
<li><p>Implementation1: basic with array index</p>
<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Tire_Array.png" alt="showcase"></li>
<li>第一“排”也可以是很多个节点&#x2F;array</li>
<li>Runtime<ol>
<li>Add: Θ(L)</li>
<li>Contains: O(L)</li>
</ol>
</li>
<li>Downside: 空间浪费比较多</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">   <span class="comment">// set a range !!! 是有范围的</span></span><br><span class="line">   <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;</span><br><span class="line">      <span class="keyword">private</span> DataIndexCharMap&lt;Node&gt; next;</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> c, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         isKey = c;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedCharMap</span>&lt;V&gt; &#123;</span><br><span class="line">      <span class="keyword">private</span> V[] items;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">DataIndexedCharMap</span><span class="params">(<span class="type">int</span> R)</span> &#123;</span><br><span class="line">         items = (V[]) <span class="keyword">new</span> <span class="title class_">Object</span>[R];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>other Implementation</p>
<ol>
<li>hashtable: 需要摊销，几乎一样快<ol>
<li>Hash Table is O(R), where R is size of alphabet</li>
</ol>
</li>
<li>BST(不一定要是Binary了)：比较慢一点，但是内存少</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>现实</strong><ol>
<li>虽然是O(1)，但是要把字符串拆开来一个一个匹配，不一定比hashing快</li>
<li>实际用处<ol>
<li><p>前缀匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collect all keys persudocode</span></span><br><span class="line">collect():</span><br><span class="line">   Create an empty list of results x.</span><br><span class="line">   For character c in root.next.keys():</span><br><span class="line">      Call <span class="title function_">colHelp</span><span class="params">(“c”, x, root.next.get(c)</span>).</span><br><span class="line">   Return x.</span><br><span class="line">      </span><br><span class="line">colHelp(String s, List&lt;String&gt; x, Node n):</span><br><span class="line">   If n.isKey, then x.add(s).</span><br><span class="line">   For character c in n.next.keys():</span><br><span class="line">      Call <span class="title function_">colHelp</span><span class="params">(s + c, x, n.next.get(c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// keysWithPrefix</span></span><br><span class="line">keysWithPrefix()</span><br><span class="line">   Find the node α corresponding to the <span class="title function_">string</span> <span class="params">(in pink)</span>.</span><br><span class="line">   Create an empty list x.</span><br><span class="line">   For character c in α.next.keys():</span><br><span class="line">      Call <span class="title function_">colHelp</span><span class="params">(“sa” + c, x, α.next.get(c)</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>AutoComplete</p>
<ol>
<li>Value represents how important Google thinks that string is – 使用权重</li>
<li>Each node stores its own value, as well as the value of its best substring</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Trie_AutoComplete.png" alt="pic"></li>
</ol>
</li>
</ol>
</li>
<li>other:There are many other types of string sets&#x2F;maps out there.<ol>
<li>Suffix Trees (Link).</li>
<li>DAWG (Link).</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="6-7-DAGs-Reduction-Decomposition"><a href="#6-7-DAGs-Reduction-Decomposition" class="headerlink" title="6. 7 DAGs, Reduction, Decomposition"></a>6. 7 DAGs, Reduction, Decomposition</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1Bvf4PooGooUCr-K9cA1kbhsNc0hXW5Jwn-QD0in-1pc/edit#slide=id.g55ec4e88d2_1_1309">graph summary</a></p>
</li>
<li><p>本届内容对于DAGs(有向无环图成立)，图的边权重可以为负的 – 算法可以运行，但是没有依赖关系，没有意义</p>
</li>
<li><p>Topological Sorting</p>
<ol>
<li>一个图中节点的排列有顺序<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Topo_name.png" alt="showcass"></li>
<li>how to find?<ol>
<li><p>solution1: DFS traversal(现在有两个含义了)</p>
<ol>
<li>成立原理: dfs postorder(最后才到source) + marked(唯一性)</li>
<li>time O(V+E), space theta(V)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persudocode</span></span><br><span class="line"><span class="number">3.</span> Perform a DFS traversal from every vertex with indegree <span class="number">0</span>,</span><br><span class="line">and NOT clearing markings in between traversals.</span><br><span class="line"><span class="number">4.</span> Record DFS postorder in a list.</span><br><span class="line"><span class="number">5.</span> Topological ordering is given by the reverse of that <span class="title function_">list</span> <span class="params">(reverse postorder)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">// improved persudocode</span></span><br><span class="line">   <span class="comment">// 无需找到入度为0的</span></span><br><span class="line">Run DFS from an arbitrary vertex.</span><br><span class="line">If not all marked, pick an unmarked vertex and <span class="keyword">do</span> it again.</span><br><span class="line">Repeat until done</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Shortest Path in DAGs: using the topological sort solution as a subroutine</p>
<ol>
<li>without negative – dijkstra</li>
<li>with negative – visit v in topological order<ol>
<li><p>不能使用dijkstra是因为不会realx负后不会再relax后面节点的总长度 – 本质：无法确保每一次选取的点是最优的</p>
</li>
<li><p>为什么可以使用topological order – 本质：拓扑顺序的访问是唯一的，Each vertex is visited only when all possible info about it has been used，使得经过某个点的时候已经可以确定到这个点的最短路径了</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1CfnLS3FSXV8X2sXPTravZGXeBUUkcFQv7Uf2iGWGUfs/edit#slide=id.g55eae46bdb_0_456">演示</a></li>
<li>time complexity: O(V+E), space complexity: theta(V)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Visit vertices in topological order.</span><br><span class="line">On each visit, relax all outgoing edges.</span><br><span class="line">   <span class="comment">// 上一步是都要relax，而不是marked这样</span></span><br><span class="line">   <span class="comment">// 始终按照topological走而不是min的，与dijsktra不一样</span></span><br><span class="line">   <span class="comment">// 设置当前最短的边为prenode</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>LPT: longest path without cycle</p>
<ol>
<li>对于普遍的无环图: unsolved O(n!)</li>
<li>对于DAGs: O(V+E) runtime – SPT算法加上-号</li>
</ol>
</li>
<li><p>Reduction</p>
<ol>
<li>DAG-LPT reduces to DAG-SPT</li>
</ol>
</li>
<li><p>Decomposition: 分解为子问题</p>
</li>
</ol>
<h2 id="7-Sorting"><a href="#7-Sorting" class="headerlink" title="7. Sorting"></a>7. Sorting</h2><h3 id="7-1-Basic-Sorts"><a href="#7-1-Basic-Sorts" class="headerlink" title="7. 1 Basic Sorts"></a>7. 1 Basic Sorts</h3><ol>
<li><p>排序的作用</p>
<ol>
<li>二分查找</li>
<li>重复匹配</li>
<li>与balanced data structure进行变换</li>
</ol>
</li>
<li><p>Notes</p>
<ol>
<li>自定义比较(与.equals()不同)：Ordering relations are typically given in the form of compareTo or compare methods. – Comparator&lt;T&gt; 或者 Comparable&lt;T&gt;</li>
<li>转位(inversion)</li>
</ol>
</li>
<li><p><em><strong>First: Selection Sort</strong></em></p>
<ol>
<li>runtime: theta(n^2)</li>
<li>idea: every time find smallest item</li>
</ol>
</li>
<li><p><em><strong>Second: Heap Sort</strong></em></p>
<ol>
<li><p>Idea: using max-oriented heap</p>
<ol>
<li>不是最小堆 – 因为数组开头被占据了如果in place的话</li>
<li>min-heap也可以，但是会比较复杂一点</li>
</ol>
</li>
<li><p>runtime: O(nlogn), space takes O(n) &gt; O(1) but can make it in place, best time is theta(n)</p>
<ol>
<li>Extra for experts, show that bottom-up heapification is Θ(N) in the worst case.</li>
<li>More extra for experts, show heapsort is Θ(N log N) in the worst case.</li>
</ol>
</li>
<li><p>persudocode</p>
<ol>
<li>in-place heap sort:是通过反向确定最小堆来实现的<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1SzcQC48OB9agStD0dFRgccU-tyjD6m3esrSC-GLxmNc/edit#slide=id.g12a2a1b52f_0_409">showcase</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. naive heap sort not in  place</span></span><br><span class="line">Insert all items into a max heap, and discard input array.</span><br><span class="line">Create output array.</span><br><span class="line">Repeat N times:</span><br><span class="line">   Delete largest item from the max heap.</span><br><span class="line">   Put largest item at the end of the unused part of the output array.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. in-place heap sort</span></span><br><span class="line">Bottom-up heapify input array:</span><br><span class="line">   Sink nodes in reverse level order: sink(k)</span><br><span class="line">   <span class="comment">// in reverse order</span></span><br><span class="line">Repeat N times:</span><br><span class="line">   Delete largest item from the max heap, swapping root with last item in the heap.</span><br><span class="line">   <span class="comment">// for heap is in the front</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><em><strong>Third: Merge Sort</strong></em></p>
<ol>
<li><p>runtime: theta(nlogn), space theta(n)</p>
</li>
<li><p>In-place? – also possible to do in-place merge sort, but algorithm is very complicated, and runtime performance suffers by a significant constant factor.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1h-gS13kKWSKd_5gt2FPXLYigFY4jf5rBkNFl3qZzRRw/pub?start=false&loop=false&delayms=3000#slide=id.g12a3009c32_0_325">showcase</a></p>
</li>
<li><p>persudocode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Split items into <span class="number">2</span> roughly even pieces -- until size == <span class="number">1</span></span><br><span class="line">Mergesort each <span class="title function_">half</span> <span class="params">(steps not shown, <span class="built_in">this</span> is a recursive algorithm!)</span></span><br><span class="line">Merge the two sorted halves to form the <span class="keyword">final</span> result.</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><em><strong>Four: Insertion Sort</strong></em></p>
<ol>
<li><p>runtime and visualizing</p>
<ol>
<li>best Omega(n), worst o(n^2), 使用三角形来可视化，倒置(小到大)的话三角形满了</li>
</ol>
</li>
<li><p>persudocode</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/10b9aRqpGJu8pUk8OpfqUIEEm8ou-zmmC7b_BE5wgNg0/edit#slide=id.g12a2f94aac_0_127">in-place showcase</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// naive approach: build output</span></span><br><span class="line">Starting with an empty output sequence.</span><br><span class="line">Add each item from input, inserting into output at right point.</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-place insertion sort</span></span><br><span class="line">Repeat <span class="type">for</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> to N - <span class="number">1</span>:</span><br><span class="line">Designate item i as the traveling item.</span><br><span class="line">Swap item forward until traveller is in the right place among all previously examined items</span><br><span class="line">   <span class="comment">// 实际中使用i,j“双指针”</span></span><br><span class="line">   <span class="comment">// 算法的正确性 -- i所过的地方都是已经排序的</span></span><br><span class="line">   <span class="comment">// 时间复杂度是一样的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>more about insertion sort</p>
</li>
</ol>
</li>
<li><p><em><strong>Added: Shell Sort</strong></em></p>
<ol>
<li>Key Idea<ol>
<li>Instead of comparing adjacent items, compare items that are one stride length h apart.</li>
<li>Start with large stride, and decrease towards 1.</li>
<li>Example: h &#x3D; 7, 3, 1.</li>
</ol>
</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_shellsort.png" alt="shell sort showcase"><ol>
<li>By using large strides first, fixes most of the inversions.</li>
<li>We used 7, 3, 1. Can generalize to 2k - 1 from some k down to 1.</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_differentShellsort.png" alt="different shell sort"></li>
</ol>
</li>
</ol>
</li>
<li><p>which sort should i use?</p>
<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_basicRuntime.png" alt="Sort_basicRuntime"><ol>
<li>heap sort跨越大地方去找在系统上叫做caching</li>
</ol>
</li>
<li>almost sorted array: 绝对是 insertion sort – merge还是会需要很多合并(相当于重复操作了)，heap拿出最大需要nlogn</li>
<li>One exchange per inversion (and number of comparisons is similar). Runtime is Θ(N + K) where K is number of inversions – 多少逆序就需要逆几次</li>
<li>Define an almost sorted array as one in which number of inversions ≤ cN for some c. Insertion sort is excellent on these arrays.</li>
<li>For small arrays (N &lt; 15 or so), insertion sort is fastest</li>
</ol>
</li>
</ol>
<h3 id="7-2-Quick-Sorts"><a href="#7-2-Quick-Sorts" class="headerlink" title="7. 2 Quick Sorts"></a>7. 2 Quick Sorts</h3><ol>
<li><p>Key Idea: Partitioning(分区)</p>
<ol>
<li><p>在元素 x&#x3D;a[i] 上分割数组 a[]，就是重新排列 a[]，使得</p>
<ol>
<li>x 移动到位置 j（可能与 i 相同）</li>
<li>x 左边的所有条目 &lt;&#x3D; x，x 右边的所有条目 &gt;&#x3D; x</li>
</ol>
</li>
<li><p>如何进行分区？ – 子问题</p>
<ol>
<li>Simplest (but not fastest) Answer: 3 Scan Approach – 扫描三次，每次只关注一件事</li>
<li>also: 扫描一次，小的放最左，大的放最右</li>
</ol>
</li>
<li><p>persudocode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Partition on leftmost item. </span><br><span class="line">Quicksort left half.</span><br><span class="line">Quicksort right half.</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Runtime: best theta(nlogn), worst theta(n^2), average theta(nlogn) empirically; space: theta(n) using recursion</p>
<ol>
<li>For most common situations, it is empirically the fastest sort – pivot matters</li>
<li>理解：与merge sort无需再每一层都进行复制，只需要移动某一个即可，merge sort合并时还要进行比较按照顺序</li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_quickaverage.png" alt="quicksort average"></li>
</ol>
</li>
<li><p>Quick is BST inorder sort, all about partitioning</p>
<ol>
<li>Random insertion into a BST takes O(N log N) time，平均也是O(nlogn)</li>
<li>也有其他的树排序，但是不如binary search tree优雅</li>
</ol>
</li>
</ol>
<h3 id="7-3-More-Quick-Sort-Comparision-Based-Sorting-Summary"><a href="#7-3-More-Quick-Sort-Comparision-Based-Sorting-Summary" class="headerlink" title="7. 3  More Quick Sort, (Comparision Based) Sorting Summary"></a>7. 3  More Quick Sort, (Comparision Based) Sorting Summary</h3><ol>
<li><em><strong>Avoid Worst Case</strong></em><ol>
<li>举例如下<ol>
<li>Bad ordering: Array already in sorted order (or almost sorted order).</li>
<li>Bad elements: Array with all duplicates – tricky</li>
</ol>
</li>
<li>思维<ol>
<li>Randomness: Pick a random pivot or shuffle before sorting<ol>
<li>可以攻破：The resulting Quicksort has a family of dangerous inputs that an adversary could easily generate</li>
</ol>
</li>
<li>Smarter pivot selection: Calculate or approximate the median<ol>
<li>安全但是不高效：Could calculate the actual median in linear time. “Exact median Quicksort” is safe: Worst case Θ(N log N), but it is slower than Mergesort.</li>
</ol>
</li>
<li>Introspection: Switch to a safer sort if recursion goes to deep</li>
</ol>
</li>
<li>对于第二各想法 – 中位数：find the median in Θ(N) time?<ol>
<li>BFPRT – Quicksort using PICK to find the exact median (Quicksort PickTH) is terrible! Cost to compute medians is too high.</li>
<li>another one median identification algorithm: Quick Select – using partitioning<ol>
<li>只考虑对它有用的部分，N+N&#x2F;2+N&#x2F;4+…+1&#x3D;theta(n)</li>
<li>使用这个来quick sort也很慢</li>
</ol>
</li>
</ol>
</li>
<li>随机Randomness挺好的</li>
</ol>
</li>
<li>Tony Hoare’s In-place Partitioning Scheme<ol>
<li><p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/">showcase</a></p>
</li>
<li><p>persudocode发明者的实现: L, G两个指针，如果cross，说明左都小，右都大，此时可以将pivot与G互换(如果pivot是第一个，与他换的必须是小的，如果选的不是最左边的，与最左变换reduces)</p>
<ol>
<li>为什么要在&#x3D;&#x3D;处停？可以避免全部相等时的O(n^2)???</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Left pointer loves small items.</span><br><span class="line">Right pointer loves large items.</span><br><span class="line">Big idea: Walk towards each other, swapping anything they don’t like.</span><br><span class="line">   when meet hated items, stop. when the two all stop, exchange</span><br><span class="line">   <span class="comment">// End result is that</span></span><br><span class="line">   <span class="comment">// things on left are “small”</span></span><br><span class="line">   <span class="comment">// things on the right are “large”.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 详细版本</span></span><br><span class="line"><span class="number">1.</span> Create L and G pointers at left and right ends.</span><br><span class="line">   <span class="number">1.</span> L pointer is a friend to small items, and hates large or equal items.</span><br><span class="line">   <span class="number">2.</span> G pointer is a friend to large items, and hates small or equal items.</span><br><span class="line"><span class="number">2.</span> Walk pointers towards each other, stopping on a hated item.</span><br><span class="line">   <span class="number">1.</span> When both pointers have stopped, swap and move pointers by one.</span><br><span class="line">   <span class="number">2.</span> When pointers cross, you are done walking.</span><br><span class="line"><span class="number">3.</span> Swap pivot with G.</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_quickRuntime.png" alt="runtime"></p>
</li>
</ol>
</li>
<li>java中的quick sort不好的输入会导致程序的崩溃 – 为什么不在递归过深时中断呢?不知道java他们怎么想</li>
<li>Stability, Adaptiveness, Optimization<ol>
<li>是否stable – Equivalent items 的顺序是否会改变<img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_stable.png" alt="stable?"><ol>
<li>举例：insertion sort就是stable的，因为不会改变一样的次序</li>
<li>Quick Sort其实也可以是，(分区策略)但是会比较慢</li>
</ol>
</li>
<li>Optimzation Skills<ol>
<li>switch to insertion sort: When a subproblem reaches size 15 or lower, use insertion sort.</li>
<li>Make sort adaptive: Exploit existing order in array (Insertion Sort, SmoothSort, TimSort (the sort in Python and Java)).</li>
<li>Exploit restrictions on set of keys. If number of keys is some constant, e.g. [3, 4, 1, 2, 4, 3, …, 2, 2, 2, 1, 4, 3, 2, 3], can sort faster (see 3-way quicksort – if you’re curious, see:  <a target="_blank" rel="noopener" href="http://goo.gl/4sYnv3">荷兰旗问题</a>)</li>
<li>For Quicksort: Make the algorithm introspective, switching to a different sorting method if recursion goes too deep. Only a problem for deterministic flavors of Quicksort.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="7-4-Sorting-and-Algorithmic-Bounds"><a href="#7-4-Sorting-and-Algorithmic-Bounds" class="headerlink" title="7. 4 Sorting and Algorithmic Bounds"></a>7. 4 Sorting and Algorithmic Bounds</h3><ol>
<li>Core Idea: Problem provide a lower bound for solution – outer set is the lower bound</li>
<li>Math<ol>
<li>N! ∈ Ω((N&#x2F;2)^(N&#x2F;2))<ol>
<li>equals to: factorial grow at least as quickly as (N&#x2F;2)^(N&#x2F;2)</li>
<li>可以举例来论证，不要求严格证明</li>
</ol>
</li>
<li>推论1: log(N!) ∈ Ω(NlogN): 取对数就好了</li>
<li>N log N ∈ Ω(log(N!))<ol>
<li>拆开来即可</li>
</ol>
</li>
<li>Conclusion: N log N ∈ Θ(log N!), log N! ∈ Θ(N log N) –&gt; N log N &#x3D; log(N!)</li>
</ol>
</li>
<li>Theoretical Bounds on Sorting<ol>
<li>初步推理: Worst case asymptotic runtime of TUCS is between Θ(N) and Θ(N log N).</li>
<li>跳脱一下思维： Puppy, Cat, Dog Problem<ol>
<li>决策树，最多有N!个可能性，树最矮为log(N!)与Nlog(N)渐进Puppy, Cat, Dog</li>
<li>Puppy, Cat, Dog 问题为 Omega(NlogN)</li>
<li>提一嘴: Finding an optimal decision tree for the generalized version of puppy, cat, dog (e.g. N&#x3D;6: puppy, cat, dog, monkey, walrus, elephant) is an open problem in mathematics.</li>
</ol>
</li>
<li>回来了: Puppy, Cat, Dog Problem reduces to Sorting – Thus, any lower bound on difficulty of puppy, cat, dog must ALSO apply to sorting.</li>
</ol>
</li>
</ol>
<h3 id="7-5-Radix-Sorts"><a href="#7-5-Radix-Sorts" class="headerlink" title="7. 5 Radix Sorts"></a>7. 5 Radix Sorts</h3><ol>
<li>引入一个怪异的sort – “Sleeping Sort” for integer, runtime N+Max(A)</li>
<li>Counting Sort<ol>
<li>初始想法(only for integer as key): Exploiting Space Instead of Time, key value -&gt; index</li>
<li>Generlizing – Alphabet case: Keys belong to a finite ordered alphabet<ol>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1vmVKHRSwb5WN1rHvktplbPGecHChxOwWa7ovRuiLzbA/">steps</a>: appearance counts -&gt; starting index -&gt; copying</li>
<li>Runtime: Total runtime on N keys with alphabet of size R: Θ(N+R)</li>
</ol>
</li>
<li>Which is faster? Counting Sort or Quick Sort<ol>
<li>For sufficiently large collections, counting sort will simply be faster</li>
<li>alphabet也很重要</li>
</ol>
</li>
</ol>
</li>
<li>Radix Sort: Extension of Counting Sort 解决有限字母表的无限排列问题<ol>
<li>LSD(least significant digit) Radix Sort – Stable<ol>
<li>Idea: 从最右边开始对每一个位进行逐一排序</li>
<li><a href="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_LSDshowcase.png">Showcase</a></li>
<li>Runtime: Θ(WN+WR)<ol>
<li>N: Number of items</li>
<li>R: size of alphabet</li>
<li>W: Width of each item in # digitsa</li>
<li>具有长版效应</li>
</ol>
</li>
</ol>
</li>
<li>MSD(most significant digit) Radix Sort<ol>
<li>Idea: 从最左边，but这里需要使用子问题来解决，否则低位的优先级”会高于”高位导致排序出错</li>
<li>Runtime: Best theta(N+R), Worst(WN+WR)</li>
</ol>
</li>
<li>Merge Sort on strings of length W<ol>
<li>Θ(N log N) if each comparison takes constant time – 字符串都不同</li>
<li>Θ(WN log N) if each comparison takes Θ(W) time – 字符串都相同</li>
</ol>
</li>
<li>Which is Better?<ol>
<li>When might LSD sort be faster<ol>
<li>Sufficiently large N.</li>
<li>If strings are very similar to each other.</li>
<li>Each Merge Sort comparison costs Θ(W) time.</li>
</ol>
</li>
<li>When might Merge Sort be faster?<ol>
<li>If strings are highly dissimilar from each other. – 此时LSD中很多比较其实是浪费</li>
<li>Each Merge Sort comparison is very fast.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>LSD Radix Sort on Integer<ol>
<li>方法：Could convert into a String and treat as a base 10 number</li>
<li>可以考虑不同进制 – Runtime depends on the alphabet size<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_LSDbase.png" alt="showcase"></li>
<li>为什么不同base间比较速率不同: 与数据的分布有关，并且比较是按照digit进行比较的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="7-6-Sorting-and-Data-Structures-Conclusion"><a href="#7-6-Sorting-and-Data-Structures-Conclusion" class="headerlink" title="7. 6 Sorting and Data Structures Conclusion"></a>7. 6 Sorting and Data Structures Conclusion</h3><ol>
<li>Things we should know when analysing<ol>
<li>Just-In-Time Compiler secretly optimizes your code when it runs</li>
<li>perform computational experiments makes things better</li>
<li>There’s always the chance that some small optimization to an algorithm can make it significantly faster.</li>
<li>主要动作是比较，但是其他动作有时也要进行考虑</li>
<li>混合思想<ol>
<li>If an object has both digits AND is comparable, could we somehow use an LLRB to improve radix sort in some way?</li>
<li>java中的hashmap对于可以comparable的对象存储在红黑树中</li>
</ol>
</li>
</ol>
</li>
<li>Three basic flavors: Comparison, Alphabet, and Radix based!<ol>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/Sort_Summary.png" alt="total summary"></li>
<li><img src="/pic/CS61B%E5%B0%8F%E7%BB%9321/DS_and_Sorting.png" alt="Ds"></li>
</ol>
</li>
</ol>
<h3 id="7-7-Sorting-Implementation-Extra-in-“Sorting-and-Algorithmic-Bounds”-ppt"><a href="#7-7-Sorting-Implementation-Extra-in-“Sorting-and-Algorithmic-Bounds”-ppt" class="headerlink" title="7. 7 Sorting Implementation (Extra in “Sorting and Algorithmic Bounds” ppt)"></a>7. 7 Sorting Implementation (Extra in “Sorting and Algorithmic Bounds” ppt)</h3><ol>
<li>没有quick sort，可以看看</li>
</ol>
<h2 id="8-Extra-Topic-SoftWare-Engineering"><a href="#8-Extra-Topic-SoftWare-Engineering" class="headerlink" title="8. Extra Topic: SoftWare Engineering"></a>8. Extra Topic: SoftWare Engineering</h2><blockquote>
<p>这一部分看着没啥意思，看着玩，还是要自己动手啊</p>
</blockquote>
<h3 id="8-1-SE-I-Complexity"><a href="#8-1-SE-I-Complexity" class="headerlink" title="8. 1 SE I: Complexity"></a>8. 1 SE I: Complexity</h3><ol>
<li>Complexity(复杂程度)<ol>
<li>表现形式<ol>
<li>变化放大： 一个简单更改需要在许多地方进行修改</li>
<li>认知负荷： 进行修改需要了解多少知识</li>
<li>未知数： 最糟糕的复杂性类型</li>
</ol>
</li>
<li>Pholosiphy<ol>
<li>0容忍 – 防止堆积</li>
<li>Strategic Programming(全局意识) – 但是实时应变，系统无法一开始就完美设计</li>
<li>可读性<ol>
<li>不添加过多特殊情况 – if&#x2F;else</li>
<li>重要信息与依赖管理</li>
<li>Compiler will optimize</li>
<li>Encapsulate 封装</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="8-2-SE-II-Modular"><a href="#8-2-SE-II-Modular" class="headerlink" title="8. 2 SE II: Modular"></a>8. 2 SE II: Modular</h3><ol>
<li>看过但是没记下来，印象中没有什么重要的东西</li>
</ol>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Index"><span class="toc-number">1.</span> <span class="toc-text">Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resources"><span class="toc-number">2.</span> <span class="toc-text">Resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-A"><span class="toc-number">3.</span> <span class="toc-text">Q&amp;A</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Principle-of-DataStruct"><span class="toc-number">4.</span> <span class="toc-text">Principle of DataStruct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-Extension"><span class="toc-number">5.</span> <span class="toc-text">0. Extension</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-Javadoc"><span class="toc-number">5.1.</span> <span class="toc-text">0. 1. Javadoc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">0. 2 垃圾回收条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-3-HOF-after-include-java-8"><span class="toc-number">5.3.</span> <span class="toc-text">0. 3 HOF after&#x2F;include java 8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-4-CallBack-Function-in-Java-%E6%90%9CSubtype-Polymorphism-vs-HoFs"><span class="toc-number">5.4.</span> <span class="toc-text">0. 4 CallBack Function in Java(搜Subtype Polymorphism vs. HoFs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-5-Nested-Class%E4%B8%8EInterface%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%BA%A7%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">0. 5 Nested Class与Interface的访问控制级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-6-How-to-deal-with-Exceptions"><span class="toc-number">5.6.</span> <span class="toc-text">0. 6 How to deal with Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-7-Set-of-E%E2%80%A6-%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.7.</span> <span class="toc-text">0. 7 Set.of(E…)方法用于可以直接进行初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Basic-Classes-and-Testing"><span class="toc-number">6.</span> <span class="toc-text">1. Basic Classes and Testing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Defining-and-Using-Classes"><span class="toc-number">6.1.</span> <span class="toc-text">1. 1 Defining and Using Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Testing"><span class="toc-number">6.2.</span> <span class="toc-text">1. 2 Testing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lists-Introduction"><span class="toc-number">7.</span> <span class="toc-text">2. Lists(Introduction)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-References-Recursion-and-Lists"><span class="toc-number">7.1.</span> <span class="toc-text">2. 1 References,Recursion,and Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SLLists-Nested-Classes-Sentinel-Nodes"><span class="toc-number">7.2.</span> <span class="toc-text">2. 2 SLLists, Nested Classes, Sentinel Nodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-DLLists-Arrays"><span class="toc-number">7.3.</span> <span class="toc-text">2. 3 DLLists, Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-ALists-Resizing"><span class="toc-number">7.4.</span> <span class="toc-text">2. 4 ALists, Resizing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Futher-Java-Feature"><span class="toc-number">8.</span> <span class="toc-text">3. Futher Java Feature</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Inheritance-Implements"><span class="toc-number">8.1.</span> <span class="toc-text">3. 1 Inheritance, Implements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Extends-Casting-Higher-Order-Functions"><span class="toc-number">8.2.</span> <span class="toc-text">3. 2 Extends, Casting, Higher Order Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Subtype-Polymorphism-vs-HoFs"><span class="toc-number">8.3.</span> <span class="toc-text">3. 3 Subtype Polymorphism vs. HoFs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Java-Packages-and-Library-gitbook"><span class="toc-number">8.4.</span> <span class="toc-text">3. 4 Java Packages and Library(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Exceptions-Iterators-Object-Methods"><span class="toc-number">8.5.</span> <span class="toc-text">3. 5 Exceptions, Iterators, Object Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-JAR-FILE-gitbook"><span class="toc-number">8.6.</span> <span class="toc-text">3. 6 JAR FILE(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Access-Control-gitbook"><span class="toc-number">8.7.</span> <span class="toc-text">3. 7 Access Control(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-Generic-and-AutoBoxing-gitbook"><span class="toc-number">8.8.</span> <span class="toc-text">3. 8 Generic and AutoBoxing(gitbook)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Abstraction-ADTs-and-Asymtotics-Annlysis"><span class="toc-number">9.</span> <span class="toc-text">4. Abstraction, ADTs and Asymtotics Annlysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-OurMap-gitbook"><span class="toc-number">9.1.</span> <span class="toc-text">4. 1 OurMap(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Encapsulation-API%E2%80%99s-ADT%E2%80%99s"><span class="toc-number">9.2.</span> <span class="toc-text">4. 2 Encapsulation, API’s, ADT’s</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Asymptotics-I-II"><span class="toc-number">9.3.</span> <span class="toc-text">4. 3 Asymptotics I II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Omega-and-Amortized-Analysis-gitbook"><span class="toc-number">9.4.</span> <span class="toc-text">4. 4 Omega and Amortized Analysis(gitbook)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Disjoint-Sets-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86"><span class="toc-number">9.5.</span> <span class="toc-text">4. 5 Disjoint Sets(不相交集)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Trees-and-Hashing"><span class="toc-number">10.</span> <span class="toc-text">5. Trees and Hashing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Binary-Search-Tree-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">10.1.</span> <span class="toc-text">5. 1 Binary Search Tree(二叉搜索树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-B-Tree-Maybe-Boeing-Tree"><span class="toc-number">10.2.</span> <span class="toc-text">5. 2 B-Tree (Maybe Boeing Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Black-Red-Tree-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text">5. 3 Black-Red-Tree (红黑树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Hashing"><span class="toc-number">10.4.</span> <span class="toc-text">5. 4 Hashing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Heaps-and-PQs"><span class="toc-number">10.5.</span> <span class="toc-text">5. 5 Heaps and PQs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Data-Structure-Summary"><span class="toc-number">10.6.</span> <span class="toc-text">5. 6 Data Structure Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Compression-Originally-38"><span class="toc-number">10.7.</span> <span class="toc-text">5. 7 Compression(Originally 38)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-Compression-Complexity-and-P-NP"><span class="toc-number">10.8.</span> <span class="toc-text">5. 8 Compression, Complexity, and P&#x3D;NP?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Graphs"><span class="toc-number">11.</span> <span class="toc-text">6. Graphs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Tree-and-Graph-Traversals"><span class="toc-number">11.1.</span> <span class="toc-text">6. 1 Tree and Graph Traversals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Graph-Traversals-and-Implementations-BFS-and-DFS"><span class="toc-number">11.2.</span> <span class="toc-text">6. 2 Graph Traversals and Implementations(BFS and DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Shortest-Paths"><span class="toc-number">11.3.</span> <span class="toc-text">6. 3 Shortest Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Minimum-Spanning-Trees"><span class="toc-number">11.4.</span> <span class="toc-text">6. 4 Minimum Spanning Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Range-Searching-and-Multi-Dimensional-Data"><span class="toc-number">11.5.</span> <span class="toc-text">6. 5 Range Searching and Multi-Dimensional Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-Prefix-Operations-and-Tries"><span class="toc-number">11.6.</span> <span class="toc-text">6. 6 Prefix Operations and Tries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-DAGs-Reduction-Decomposition"><span class="toc-number">11.7.</span> <span class="toc-text">6. 7 DAGs, Reduction, Decomposition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Sorting"><span class="toc-number">12.</span> <span class="toc-text">7. Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Basic-Sorts"><span class="toc-number">12.1.</span> <span class="toc-text">7. 1 Basic Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Quick-Sorts"><span class="toc-number">12.2.</span> <span class="toc-text">7. 2 Quick Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-More-Quick-Sort-Comparision-Based-Sorting-Summary"><span class="toc-number">12.3.</span> <span class="toc-text">7. 3  More Quick Sort, (Comparision Based) Sorting Summary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-Sorting-and-Algorithmic-Bounds"><span class="toc-number">12.4.</span> <span class="toc-text">7. 4 Sorting and Algorithmic Bounds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-Radix-Sorts"><span class="toc-number">12.5.</span> <span class="toc-text">7. 5 Radix Sorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-Sorting-and-Data-Structures-Conclusion"><span class="toc-number">12.6.</span> <span class="toc-text">7. 6 Sorting and Data Structures Conclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-Sorting-Implementation-Extra-in-%E2%80%9CSorting-and-Algorithmic-Bounds%E2%80%9D-ppt"><span class="toc-number">12.7.</span> <span class="toc-text">7. 7 Sorting Implementation (Extra in “Sorting and Algorithmic Bounds” ppt)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Extra-Topic-SoftWare-Engineering"><span class="toc-number">13.</span> <span class="toc-text">8. Extra Topic: SoftWare Engineering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-SE-I-Complexity"><span class="toc-number">13.1.</span> <span class="toc-text">8. 1 SE I: Complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-SE-II-Modular"><span class="toc-number">13.2.</span> <span class="toc-text">8. 2 SE II: Modular</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&text=CS61B小结21"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&is_video=false&description=CS61B小结21"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CS61B小结21&body=Check out this article: https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&title=CS61B小结21"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&name=CS61B小结21&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://kc1zs4.github.io/2024/09/15/CS61B%E5%B0%8F%E7%BB%9321/&t=CS61B小结21"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    KC1zs4&#39;s Blog
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

  
<script src="/js/search.js"></script>

  <script type="text/javascript">
  $(function() {

    var $inputArea = $("input#search-input");
    var $resultArea = document.querySelector("div#search-result");

    $inputArea.focus(function() {
      var search_path = "search.xml";
      if (search_path.length == 0) {
        search_path = "search.xml";
      }
      var path = "/" + search_path;
      searchFunc(path, 'search-input', 'search-result');
    });

    $inputArea.keydown(function(e) {
      if (e.which == 13) {
        e.preventDefault();
      }
    });

    var observer = new MutationObserver(function(mutationsList, observer) {
      if (mutationsList.length == 1) {
        if (mutationsList[0].addedNodes.length) {
          $(".search-no-result").hide();
        } else if (mutationsList[0].removedNodes.length) {
          $(".search-no-result").show(200);
        }
      }
    });

    observer.observe($resultArea, { childList: true });

  });
  </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'kc1zs4-github-io';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
